"Angular momentum"

-- commutation relations for angular momentum operators

clear

Lx(f) = -i hbar (y d(f,z) - z d(f,y))
Ly(f) = -i hbar (z d(f,x) - x d(f,z))
Lz(f) = -i hbar (x d(f,y) - y d(f,x))

check(Lx(Ly(psi(x,y,z))) - Ly(Lx(psi(x,y,z))) == i hbar Lz(psi(x,y,z)))
check(Ly(Lz(psi(x,y,z))) - Lz(Ly(psi(x,y,z))) == i hbar Lx(psi(x,y,z)))
check(Lz(Lx(psi(x,y,z))) - Lx(Lz(psi(x,y,z))) == i hbar Ly(psi(x,y,z)))
"Annihilation demo"

clear

-- Verify formulas for electron-positron annihilation

-- Run time about 30 seconds

-- Safari recommended, click through alerts on other browsers

E = sqrt(p^2 + m^2)

p1 = (E, 0, 0, p)
p2 = (E, 0, 0, -p)

p3 = (E,
      E expsin(theta) expcos(phi),
      E expsin(theta) expsin(phi),
      E expcos(theta))

p4 = (E,
      -E expsin(theta) expcos(phi),
      -E expsin(theta) expsin(phi),
      -E expcos(theta))

-- spinors

N = (E + m)^2

u11 = (E + m, 0, p1[4], p1[2] + i p1[3])
u12 = (0, E + m, p1[2] - i p1[3], -p1[4])

v21 = (p2[4], p2[2] + i p2[3], E + m, 0)
v22 = (p2[2] - i p2[3], -p2[4], 0, E + m)

u1 = (u11,u12)
v2 = (v21,v22)

I = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))

gmunu = ((1,0,0,0),(0,-1,0,0),(0,0,-1,0),(0,0,0,-1))

gamma0 = ((1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma1 = ((0,0,0,1),(0,0,1,0),(0,-1,0,0),(-1,0,0,0))
gamma2 = ((0,0,0,-i),(0,0,i,0),(0,i,0,0),(-i,0,0,0))
gamma3 = ((0,0,1,0),(0,0,0,-1),(-1,0,0,0),(0,1,0,0))

gamma = (gamma0,gamma1,gamma2,gamma3)

gammaT = transpose(gamma)
gammaL = transpose(dot(gmunu,gamma))

v2bar = dot(conj(v2),gamma0) -- adjoint of v2

q1 = p1 - p3
q2 = p1 - p4

qslash1 = dot(q1,gmunu,gamma)
qslash2 = dot(q2,gmunu,gamma)

t = dot(q1,gmunu,q1)
u = dot(q2,gmunu,q2)

a1 = zero(2,2,4,4)
a2 = zero(2,2,4,4)

for(a,1,2, for(b,1,2,
 a1[a,b] = dot(v2bar[b], gammaT, qslash1 + m I, gammaT, u1[a]),
 a2[a,b] = dot(v2bar[b], gammaT, qslash2 + m I, gammaT, u1[a])
))

-- "Sum over spin states"

a11 = sum(a,1,2, sum(b,1,2,
 contract(dot(a1[a,b], gmunu, transpose(conj(a1[a,b])), gmunu))
))

a12 = sum(a,1,2, sum(b,1,2,
 contract(dot(a1[a,b], gmunu, conj(a2[a,b]), gmunu))
))

a22 = sum(a,1,2, sum(b,1,2,
 contract(dot(a2[a,b], gmunu, transpose(conj(a2[a,b])), gmunu))
))

S = a11 + a12 + conj(a12) + a22
-- S

-- "Verify Casimir trick"

pslash1 = dot(p1,gmunu,gamma)
pslash2 = dot(p2,gmunu,gamma)

P1 = pslash1 + m I
P2 = pslash2 - m I

Q1 = qslash1 + m I
Q2 = qslash2 + m I

T = dot(P1,gammaT,Q1,gammaT,P2,gammaL,Q1,gammaL)
f11 = contract(contract(contract(T,3,4),2,3))

T = dot(P1,gammaT,Q2,gammaT,P2,gammaL,Q1,gammaL)
f12 = contract(contract(contract(T,3,5),2,3))

T = dot(P1,gammaT,Q2,gammaT,P2,gammaL,Q2,gammaL)
f22 = contract(contract(contract(T,3,4),2,3))

check(f11 == a11 / N)
check(f12 == a12 / N)
check(f22 == a22 / N)

-- "ok"

-- "Verify Mandelstam formulas"

s = dot(p1 + p2, gmunu, p1 + p2)
t = dot(p1 - p3, gmunu, p1 - p3)
u = dot(p1 - p4, gmunu, p1 - p4)

d11 = (t - m^2)^2
d12 = (t - m^2) (u - m^2)
d22 = (u - m^2)^2

f = (f11/d11 + 2 f12/d12 + f22/d22) / 4

check(f11 == 8 t u - 24 t m^2 - 8 u m^2 - 8 m^4)
check(f12 == 8 s m^2 - 32 m^4)
check(f22 == 8 t u - 8 t m^2 - 24 u m^2 - 8 m^4)

-- "ok"

-- "Verify probability density"

p12 = dot(p1,gmunu,p2)
p13 = dot(p1,gmunu,p3)
p14 = dot(p1,gmunu,p4)

check(f11 == 32 p13 p14 - 32 m^2 p12 + 64 m^2 p13 + 32 m^2 p14 - 64 m^4)
check(f12 == 16 m^2 p13 + 16 m^2 p14 - 32 m^4)
check(f22 == 32 p13 p14 - 32 m^2 p12 + 32 m^2 p13 + 64 m^2 p14 - 64 m^4)

-- "ok"

-- "Verify probability density for m = 0"

m = 0

check(s == 4 E^2)
check(t == 2 E^2 (expcos(theta) - 1))
check(u == -2 E^2 (expcos(theta) + 1))

a = 1 + expcos(theta)
b = 1 - expcos(theta)

check(f == 2 (a/b + b/a))

m = quote(m) -- undo m = 0

-- "ok"
"Bhabha scattering demo"

clear

-- Verify formulas for Bhabha scattering

E = sqrt(p^2 + m^2)

p1 = (E, 0, 0, p)
p2 = (E, 0, 0, -p)

p3 = (E,
      p expsin(theta) expcos(phi),
      p expsin(theta) expsin(phi),
      p expcos(theta))

p4 = (E,
      -p expsin(theta) expcos(phi),
      -p expsin(theta) expsin(phi),
      -p expcos(theta))

-- spinors

N = (E + m)^4

v11 = (p1[4], p1[2] + i p1[3], E + m, 0)
v12 = (p1[2] - i p1[3], -p1[4], 0, E + m)

u21 = (E + m, 0, p2[4], p2[2] + i p2[3])
u22 = (0, E + m, p2[2] - i p2[3], -p2[4])

v31 = (p3[4], p3[2] + i p3[3], E + m, 0)
v32 = (p3[2] - i p3[3], -p3[4], 0, E + m)

u41 = (E + m, 0, p4[4], p4[2] + i p4[3])
u42 = (0, E + m, p4[2] - i p4[3], -p4[4])

v1 = (v11,v12)
u2 = (u21,u22)
v3 = (v31,v32)
u4 = (u41,u42)

I = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))

gmunu = ((1,0,0,0),(0,-1,0,0),(0,0,-1,0),(0,0,0,-1))

gamma0 = ((1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma1 = ((0,0,0,1),(0,0,1,0),(0,-1,0,0),(-1,0,0,0))
gamma2 = ((0,0,0,-i),(0,0,i,0),(0,i,0,0),(-i,0,0,0))
gamma3 = ((0,0,1,0),(0,0,0,-1),(-1,0,0,0),(0,1,0,0))

gamma = (gamma0,gamma1,gamma2,gamma3)

gammaT = transpose(gamma)
gammaL = transpose(dot(gmunu,gamma))

v1bar = dot(conj(v1),gamma0) -- adjoint of v1
u4bar = dot(conj(u4),gamma0) -- adjoint of u4

w13 = zero(2,2,4)
w42 = zero(2,2,4)
w12 = zero(2,2,4)
w43 = zero(2,2,4)

for(a,1,2, for(b,1,2,
 w13[a,b] = dot(v1bar[a], gammaT, v3[b]),
 w42[a,b] = dot(u4bar[a], gammaL, u2[b]),
 w12[a,b] = dot(v1bar[a], gammaT, u2[b]),
 w43[a,b] = dot(u4bar[a], gammaL, v3[b])
))

-- matrix elements

a1 = zero(2,2,2,2)
a2 = zero(2,2,2,2)

for(a,1,2, for(b,1,2, for(c,1,2, for(d,1,2,
 a1[a,b,c,d] = dot(w13[a,c], w42[d,b]),
 a2[a,b,c,d] = dot(w12[a,b], w43[d,c])
))))

-- "Sum over spin states"

a11 = sum(conj(a1) a1)
a12 = sum(conj(a2) a1)
a22 = sum(conj(a2) a2)

S = a11 - a12 - conj(a12) + a22
-- S

-- "Verify Casimir trick"

pslash1 = dot(p1,gmunu,gamma)
pslash2 = dot(p2,gmunu,gamma)
pslash3 = dot(p3,gmunu,gamma)
pslash4 = dot(p4,gmunu,gamma)

X1 = pslash1 - m I
X2 = pslash2 + m I
X3 = pslash3 - m I
X4 = pslash4 + m I

T1 = contract(dot(X1,gammaT,X3,gammaT),1,4)
T2 = contract(dot(X4,gammaL,X2,gammaL),1,4)
f11 = contract(dot(T1,transpose(T2)))

T = contract(dot(X1,gammaT,X2,gammaT,X4,gammaL,X3,gammaL),1,6)
f12 = contract(contract(T,1,3))

T1 = contract(dot(X1,gammaT,X2,gammaT),1,4)
T2 = contract(dot(X4,gammaL,X3,gammaL),1,4)
f22 = contract(dot(T1,transpose(T2)))

check(f11 == a11 / N)
check(f12 == a12 / N)
check(f22 == a22 / N)

-- "ok"

-- "Verify Mandelstam formulas"

s = dot(p1 + p2,gmunu,p1 + p2)
t = dot(p1 - p3,gmunu,p1 - p3)
u = dot(p1 - p4,gmunu,p1 - p4)

d11 = t^2
d12 = s t
d22 = s^2

f = (f11/d11 - 2 f12/d12 + f22/d22) / 4

check(f11 == 8 s^2 + 8 u^2 - 64 s m^2 - 64 u m^2 + 192 m^4)
check(f12 == -8 u^2 + 64 u m^2 - 96 m^4)
check(f22 == 8 t^2 + 8 u^2 - 64 t m^2 - 64 u m^2 + 192 m^4)

-- "ok"

-- "Verify probability density"

p12 = dot(p1,gmunu,p2)
p13 = dot(p1,gmunu,p3)
p14 = dot(p1,gmunu,p4)

check(f11 == 32 p12^2 + 32 p14^2 - 64 m^2 p13 + 64 m^4)
check(f12 == -32 p14^2 - 32 m^2 p12 + 32 m^2 p13 - 32 m^2 p14 - 32 m^4)
check(f22 == 32 p13^2 + 32 p14^2 + 64 m^2 p12 + 64 m^4)

-- "ok"

-- "Verify probability density for m = 0"

m = 0

check(f == (expcos(theta)^2 + 3)^2 / (expcos(theta) - 1)^2)

m = quote(m) -- undo m = 0

-- "ok"
"Birthday problem"

clear

-- Product method
p = product(k,1,23,(365-k+1)/365)
check(infixform(float(p)) == "0.492703")

-- Factorial method
p = 365! / (365 - 23)! / 365^23
check(infixform(float(p)) == "0.492703")

-- Probability of at least one shared birthday
check(infixform(1.0 - p) == "0.507297")
"Bondi metric"
clear
guu=V(u,r,theta)*1/r*exp(2*beta(u,r,theta))-U(u,r,theta)^2*r^2*exp(2*gamma(u,r,theta))
gur=2*exp(2*beta(u,r,theta))
gutheta=2*U(u,r,theta)*r^2*exp(2*gamma(u,r,theta))
gthetatheta=-1*r^2*exp(2*gamma(u,r,theta))
gphiphi=-1*r^2*exp(-2*gamma(u,r,theta))*sin(theta)^2
gdd=((guu,gur,gutheta,0),(gur,0,0,0),(gutheta,0,gthetatheta,0),(0,0,0,gphiphi))
g=det(gdd)
guu=adj(gdd)/g
tmp=d(gdd,(u,r,theta,phi))
GAMUDD=contract(1/2*outer(guu,tmp+transpose(tmp,2,3)-transpose(transpose(tmp,2,3),1,2)),2,3)
tmp1=d(GAMUDD,(u,r,theta,phi))
tmp2=contract(outer(GAMUDD,GAMUDD),2,4)
RUDDD=transpose(tmp1,3,4)-tmp1+transpose(tmp2,2,3)-transpose(transpose(tmp2,2,3),3,4)
RDD=contract(RUDDD,1,3)
R=contract(contract(outer(guu,RDD),2,3),1,2)
GDD=RDD-1/2*gdd*R

G11 = 3/4 r^4 U(u,r,theta)^4 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(gamma(u,r,theta),r)^2 - 3/4 r^4 U(u,r,theta)^2 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(U(u,r,theta),r)^2 - 3 r^3 U(u,r,theta)^4 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(beta(u,r,theta),r) + 3/2 r^3 U(u,r,theta)^4 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(gamma(u,r,theta),r) + 3/2 r^3 U(u,r,theta)^3 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(U(u,r,theta),r) + 9/4 r^2 U(u,r,theta)^4 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) + 2 r^2 U(u,r,theta)^3 cos(theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) / sin(theta) - 2 r^2 U(u,r,theta)^3 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),theta) + 2 r^2 U(u,r,theta)^3 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),theta) - 2 r^2 U(u,r,theta)^3 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) d(gamma(u,r,theta),theta) - 3 r^2 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),theta) + 3 r^2 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),theta) + r^2 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(U(u,r,theta),r),theta) - 4 r^2 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),u) + 4 r^2 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),u) - r^2 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) d(gamma(u,r,theta),u) + 2 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(U(u,r,theta),theta) - 4 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),u) + 4 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),u) + 2 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(U(u,r,theta),r),u) - 2 r U(u,r,theta)^3 cos(theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) / sin(theta) + 2 r U(u,r,theta)^3 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),theta) + r U(u,r,theta)^2 V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),r) - r U(u,r,theta)^2 V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),r) - 1/2 r U(u,r,theta)^2 V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r)^2 + r U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(V(u,r,theta),r) d(beta(u,r,theta),r) - r U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(V(u,r,theta),r) d(gamma(u,r,theta),r) - 6 r U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(beta(u,r,theta),u) + 1/2 r U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(V(u,r,theta),r),r) + 7 r U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),u) + 2 r U(u,r,theta) V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),r) - 2 r U(u,r,theta) V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),r) - r U(u,r,theta) V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(U(u,r,theta),r),r) + 3 r U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),u) - 1/4 r V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r)^2 - 9 U(u,r,theta)^2 V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) / (4 r) - U(u,r,theta) V(u,r,theta) cos(theta) d(beta(u,r,theta),r) / (r sin(theta)) - U(u,r,theta) V(u,r,theta) cos(theta) d(gamma(u,r,theta),r) / (r sin(theta)) + 2 U(u,r,theta) V(u,r,theta) d(gamma(u,r,theta),r) d(gamma(u,r,theta),theta) / r - U(u,r,theta) cos(theta) d(V(u,r,theta),r) / (2 r sin(theta)) - 2 U(u,r,theta) d(V(u,r,theta),theta) d(beta(u,r,theta),r) / r + 2 U(u,r,theta) d(V(u,r,theta),theta) d(gamma(u,r,theta),r) / r - U(u,r,theta) d(d(V(u,r,theta),r),theta) / r + V(u,r,theta) cos(theta) d(U(u,r,theta),r) / (r sin(theta)) - V(u,r,theta) d(U(u,r,theta),theta) d(beta(u,r,theta),r) / r + V(u,r,theta) d(U(u,r,theta),theta) d(gamma(u,r,theta),r) / r + V(u,r,theta) d(d(U(u,r,theta),r),theta) / r + V(u,r,theta) d(gamma(u,r,theta),r) d(gamma(u,r,theta),u) / r + d(U(u,r,theta),r) d(V(u,r,theta),theta) / (2 r) - d(U(u,r,theta),theta) d(V(u,r,theta),r) / (2 r) + 7 U(u,r,theta) V(u,r,theta) cos(theta) / (2 r^2 sin(theta)) - 2 U(u,r,theta) V(u,r,theta) d(beta(u,r,theta),theta) / r^2 + 2 U(u,r,theta) d(V(u,r,theta),theta) / r^2 - V(u,r,theta)^2 d(gamma(u,r,theta),r)^2 / (4 r^2) + 7 V(u,r,theta) d(U(u,r,theta),theta) / (2 r^2) - V(u,r,theta) d(beta(u,r,theta),u) / r^2 + d(V(u,r,theta),u) / (2 r^2) + V(u,r,theta)^2 d(beta(u,r,theta),r) / (2 r^3) - V(u,r,theta) cos(theta) exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(beta(u,r,theta),theta) / (r^3 sin(theta)) + 3 V(u,r,theta) cos(theta) exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(gamma(u,r,theta),theta) / (r^3 sin(theta)) + V(u,r,theta) exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) / r^3 - V(u,r,theta) exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(beta(u,r,theta),theta)^2 / r^3 + 2 V(u,r,theta) exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(beta(u,r,theta),theta) d(gamma(u,r,theta),theta) / r^3 - V(u,r,theta) exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(beta(u,r,theta),theta),theta) / r^3 + V(u,r,theta) exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),theta),theta) / r^3 - 2 V(u,r,theta) exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(gamma(u,r,theta),theta)^2 / r^3 - V(u,r,theta) d(V(u,r,theta),r) / (4 r^3) + cos(theta) exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(V(u,r,theta),theta) / (2 r^3 sin(theta)) + exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(V(u,r,theta),theta) d(beta(u,r,theta),theta) / r^3 - exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(V(u,r,theta),theta) d(gamma(u,r,theta),theta) / r^3 + exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(V(u,r,theta),theta),theta) / (2 r^3) - U(u,r,theta)^2 + 7/2 U(u,r,theta)^2 V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(beta(u,r,theta),r) - 5/2 U(u,r,theta)^2 V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) + 2 U(u,r,theta)^2 cos(theta) d(beta(u,r,theta),theta) / sin(theta) - 4 U(u,r,theta)^2 cos(theta) d(gamma(u,r,theta),theta) / sin(theta) - 3/4 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(V(u,r,theta),r) + U(u,r,theta)^2 d(beta(u,r,theta),theta)^2 - 2 U(u,r,theta)^2 d(beta(u,r,theta),theta) d(gamma(u,r,theta),theta) + 2 U(u,r,theta)^2 d(d(beta(u,r,theta),theta),theta) - 2 U(u,r,theta)^2 d(d(gamma(u,r,theta),theta),theta) + 2 U(u,r,theta)^2 d(gamma(u,r,theta),theta)^2 - 11/2 U(u,r,theta) V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) - U(u,r,theta) cos(theta) d(U(u,r,theta),theta) / sin(theta) + 4 U(u,r,theta) cos(theta) d(beta(u,r,theta),u) / sin(theta) - 4 U(u,r,theta) cos(theta) d(gamma(u,r,theta),u) / sin(theta) + 2 U(u,r,theta) d(U(u,r,theta),theta) d(beta(u,r,theta),theta) - 2 U(u,r,theta) d(U(u,r,theta),theta) d(gamma(u,r,theta),theta) - U(u,r,theta) d(d(U(u,r,theta),theta),theta) + 4 U(u,r,theta) d(d(beta(u,r,theta),theta),u) - 4 U(u,r,theta) d(d(gamma(u,r,theta),theta),u) - 2 cos(theta) d(U(u,r,theta),u) / sin(theta) - d(U(u,r,theta),theta)^2 + 4 d(U(u,r,theta),theta) d(beta(u,r,theta),u) - 4 d(U(u,r,theta),theta) d(gamma(u,r,theta),u) - 2 d(d(U(u,r,theta),theta),u) - 2 d(gamma(u,r,theta),u)^2

G12 = -3/2 r^2 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r)^2 + 2 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),r) - 2 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),r) - r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(U(u,r,theta),r),r) - 1/2 r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r)^2 + 6 r U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(beta(u,r,theta),r) - 3 r U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) - 7 r U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) + 4 U(u,r,theta) cos(theta) / (r sin(theta)) - 4 U(u,r,theta) d(beta(u,r,theta),theta) / r - V(u,r,theta) d(gamma(u,r,theta),r)^2 / (2 r) + 4 d(U(u,r,theta),theta) / r + V(u,r,theta) d(beta(u,r,theta),r) / r^2 - 2 cos(theta) exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(beta(u,r,theta),theta) / (r^2 sin(theta)) + 6 cos(theta) exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(gamma(u,r,theta),theta) / (r^2 sin(theta)) + 2 exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) / r^2 - 2 exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(beta(u,r,theta),theta)^2 / r^2 + 4 exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(beta(u,r,theta),theta) d(gamma(u,r,theta),theta) / r^2 - 2 exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(beta(u,r,theta),theta),theta) / r^2 + 2 exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),theta),theta) / r^2 - 4 exp(2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(gamma(u,r,theta),theta)^2 / r^2 - d(V(u,r,theta),r) / (2 r^2) - 9/2 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) - 4 U(u,r,theta) cos(theta) d(gamma(u,r,theta),r) / sin(theta) + 2 U(u,r,theta) d(d(beta(u,r,theta),r),theta) - 2 U(u,r,theta) d(d(gamma(u,r,theta),r),theta) + 4 U(u,r,theta) d(gamma(u,r,theta),r) d(gamma(u,r,theta),theta) + cos(theta) d(U(u,r,theta),r) / sin(theta) + d(d(U(u,r,theta),r),theta)

G13 = -3/2 r^4 U(u,r,theta)^3 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(gamma(u,r,theta),r)^2 + 3/2 r^4 U(u,r,theta)^2 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),r) - 3/2 r^4 U(u,r,theta)^2 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),r) - 3/4 r^4 U(u,r,theta)^2 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(d(U(u,r,theta),r),r) + 6 r^3 U(u,r,theta)^3 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(beta(u,r,theta),r) - 3 r^3 U(u,r,theta)^3 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(gamma(u,r,theta),r) - 6 r^3 U(u,r,theta)^2 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(U(u,r,theta),r) - 9/2 r^2 U(u,r,theta)^3 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) - 4 r^2 U(u,r,theta)^2 cos(theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) / sin(theta) + 5/2 r^2 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),theta) - 5/2 r^2 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),theta) + 4 r^2 U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) d(gamma(u,r,theta),theta) + r^2 U(u,r,theta) cos(theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) / sin(theta) + r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),theta) - r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),theta) + 1/2 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(U(u,r,theta),r),theta) + 2 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),u) - 2 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),u) + 2 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) d(gamma(u,r,theta),u) - 1/2 r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(U(u,r,theta),theta) + r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),u) - r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),u) - 1/2 r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(U(u,r,theta),r),u) + 4 r U(u,r,theta)^2 cos(theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) / sin(theta) - 3 r U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(beta(u,r,theta),theta) - r U(u,r,theta)^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),theta) - 1/2 r U(u,r,theta) V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),r) + 1/2 r U(u,r,theta) V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),r) - 1/2 r U(u,r,theta) V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r)^2 + 3 r U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),theta) - 1/2 r U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(V(u,r,theta),r) d(beta(u,r,theta),r) + 1/2 r U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(V(u,r,theta),r) d(gamma(u,r,theta),r) - 1/4 r U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(V(u,r,theta),r),r) - 2 r U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),u) - 1/2 r V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),r) + 1/2 r V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),r) + 1/4 r V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(U(u,r,theta),r),r) + d(V(u,r,theta),theta) d(beta(u,r,theta),r) / (2 r) - d(V(u,r,theta),theta) d(gamma(u,r,theta),r) / (2 r) + d(d(V(u,r,theta),r),theta) / (4 r) - d(V(u,r,theta),theta) / (4 r^2) + 2 U(u,r,theta) + 1/2 U(u,r,theta) V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(beta(u,r,theta),r) + 1/2 U(u,r,theta) V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) - 2 U(u,r,theta) cos(theta) d(beta(u,r,theta),theta) / sin(theta) + 6 U(u,r,theta) cos(theta) d(gamma(u,r,theta),theta) / sin(theta) - 2 U(u,r,theta) d(beta(u,r,theta),theta)^2 + 4 U(u,r,theta) d(beta(u,r,theta),theta) d(gamma(u,r,theta),theta) - 2 U(u,r,theta) d(d(beta(u,r,theta),theta),theta) + 2 U(u,r,theta) d(d(gamma(u,r,theta),theta),theta) - 4 U(u,r,theta) d(gamma(u,r,theta),theta)^2 + V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) + 2 cos(theta) d(gamma(u,r,theta),u) / sin(theta) - d(d(beta(u,r,theta),theta),u) + d(d(gamma(u,r,theta),theta),u) - 2 d(gamma(u,r,theta),theta) d(gamma(u,r,theta),u)

G22 = 4 d(beta(u,r,theta),r) / r - 2 d(gamma(u,r,theta),r)^2

G23 = -r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),r) + r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),r) + 1/2 r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(U(u,r,theta),r),r) + 2 r exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) + 2 d(beta(u,r,theta),theta) / r + 2 cos(theta) d(gamma(u,r,theta),r) / sin(theta) - d(d(beta(u,r,theta),r),theta) + d(d(gamma(u,r,theta),r),theta) - 2 d(gamma(u,r,theta),r) d(gamma(u,r,theta),theta)

G33 = 3/4 r^4 U(u,r,theta)^2 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(gamma(u,r,theta),r)^2 - 3/2 r^4 U(u,r,theta) exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),r) + 3/2 r^4 U(u,r,theta) exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),r) + 3/4 r^4 U(u,r,theta) exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(d(U(u,r,theta),r),r) - 3 r^3 U(u,r,theta)^2 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(beta(u,r,theta),r) + 3/2 r^3 U(u,r,theta)^2 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(gamma(u,r,theta),r) + 9/2 r^3 U(u,r,theta) exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) d(U(u,r,theta),r) + 9/4 r^2 U(u,r,theta)^2 exp(-4 beta(u,r,theta) + 4 gamma(u,r,theta)) + 2 r^2 U(u,r,theta) cos(theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) / sin(theta) - 2 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),theta) + 2 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),theta) - 2 r^2 U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) d(gamma(u,r,theta),theta) - r^2 cos(theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) / sin(theta) - r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),theta) + r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),theta) - r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),u) + r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),u) - r^2 exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) d(gamma(u,r,theta),u) - 2 r U(u,r,theta) cos(theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) / sin(theta) + 2 r U(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),theta) + 1/4 r V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),r) - 1/4 r V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),r) + 1/4 r V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r)^2 + 1/4 r exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(V(u,r,theta),r) d(beta(u,r,theta),r) - 1/4 r exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(V(u,r,theta),r) d(gamma(u,r,theta),r) + 1/8 r exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(d(V(u,r,theta),r),r) + r exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),u) - 1/4 V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(beta(u,r,theta),r) - 1/4 V(u,r,theta) exp(-2 beta(u,r,theta) + 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) + 2 cos(theta) d(beta(u,r,theta),theta) / sin(theta) + d(beta(u,r,theta),theta)^2 - 2 d(beta(u,r,theta),theta) d(gamma(u,r,theta),theta)

G44 = -3 r^4 U(u,r,theta)^2 sin(theta)^2 exp(-4 beta(u,r,theta)) d(beta(u,r,theta),r) d(gamma(u,r,theta),r) + 3/2 r^4 U(u,r,theta)^2 sin(theta)^2 exp(-4 beta(u,r,theta)) d(d(gamma(u,r,theta),r),r) + 15/4 r^4 U(u,r,theta)^2 sin(theta)^2 exp(-4 beta(u,r,theta)) d(gamma(u,r,theta),r)^2 - 3/2 r^4 U(u,r,theta) sin(theta)^2 exp(-4 beta(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),r) + 9/2 r^4 U(u,r,theta) sin(theta)^2 exp(-4 beta(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),r) + 3/4 r^4 U(u,r,theta) sin(theta)^2 exp(-4 beta(u,r,theta)) d(d(U(u,r,theta),r),r) + 1/2 r^4 sin(theta)^2 exp(-4 beta(u,r,theta)) d(U(u,r,theta),r)^2 - 3 r^3 U(u,r,theta)^2 sin(theta)^2 exp(-4 beta(u,r,theta)) d(beta(u,r,theta),r) + 15/2 r^3 U(u,r,theta)^2 sin(theta)^2 exp(-4 beta(u,r,theta)) d(gamma(u,r,theta),r) + 9/2 r^3 U(u,r,theta) sin(theta)^2 exp(-4 beta(u,r,theta)) d(U(u,r,theta),r) + 9/4 r^2 U(u,r,theta)^2 sin(theta)^2 exp(-4 beta(u,r,theta)) - 2 r^2 U(u,r,theta) sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),theta) - 2 r^2 U(u,r,theta) sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),theta) - 2 r^2 U(u,r,theta) sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) d(gamma(u,r,theta),theta) - r^2 sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(beta(u,r,theta),theta) - r^2 sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(U(u,r,theta),r) d(gamma(u,r,theta),theta) - 2 r^2 sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(U(u,r,theta),theta) d(gamma(u,r,theta),r) - r^2 sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(U(u,r,theta),r),theta) - r^2 sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),u) - r^2 sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),u) - r^2 sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) d(gamma(u,r,theta),u) - 2 r U(u,r,theta) sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(gamma(u,r,theta),theta) + 1/4 r V(u,r,theta) sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(beta(u,r,theta),r),r) + 1/4 r V(u,r,theta) sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(gamma(u,r,theta),r),r) + 1/4 r V(u,r,theta) sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(gamma(u,r,theta),r)^2 - 2 r sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(U(u,r,theta),theta) + 1/4 r sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(V(u,r,theta),r) d(beta(u,r,theta),r) + 1/4 r sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(V(u,r,theta),r) d(gamma(u,r,theta),r) + 1/8 r sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(d(V(u,r,theta),r),r) - r sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(gamma(u,r,theta),u) - 1/4 V(u,r,theta) sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(beta(u,r,theta),r) + 1/4 V(u,r,theta) sin(theta)^2 exp(-2 beta(u,r,theta) - 2 gamma(u,r,theta)) d(gamma(u,r,theta),r) + 3 sin(theta)^2 exp(-4 gamma(u,r,theta)) d(beta(u,r,theta),theta)^2 - 2 sin(theta)^2 exp(-4 gamma(u,r,theta)) d(beta(u,r,theta),theta) d(gamma(u,r,theta),theta) + 2 sin(theta)^2 exp(-4 gamma(u,r,theta)) d(d(beta(u,r,theta),theta),theta)

check(GDD[1,1] == G11)
check(GDD[1,2] == G12)
check(GDD[1,3] == G13)
check(GDD[1,4] == 0)

check(GDD[2,1] == G12)
check(GDD[2,2] == G22)
check(GDD[2,3] == G23)
check(GDD[2,4] == 0)

check(GDD[3,1] == G13)
check(GDD[3,2] == G23)
check(GDD[3,3] == G33)
check(GDD[3,4] == 0)

check(GDD[4,1] == 0)
check(GDD[4,2] == 0)
check(GDD[4,3] == 0)
check(GDD[4,4] == G44)

GUD=contract(outer(guu,GDD),2,3)
GUU=contract(outer(GUD,guu),2,3)
tmp=outer(GUU,GAMUDD)
tmp=d(GUU,(u,r,theta,phi))+transpose(contract(tmp,1,4),1,2)+contract(tmp,2,4)
T = contract(tmp,2,3)
check(T=(0,0,0,0))
"Casimir trick"

clear

E1 = sqrt(p1x^2 + p1y^2 + p1z^2 + m1^2)
E2 = sqrt(p2x^2 + p2y^2 + p2z^2 + m2^2)
E3 = sqrt(p3x^2 + p3y^2 + p3z^2 + m3^2)
E4 = sqrt(p4x^2 + p4y^2 + p4z^2 + m4^2)
p1 = (E1,p1x,p1y,p1z)
p2 = (E2,p2x,p2y,p2z)
p3 = (E3,p3x,p3y,p3z)
p4 = (E4,p4x,p4y,p4z)
u11 = (E1+m1,0,p1z,p1x+i*p1y)
u12 = (0,E1+m1,p1x-i*p1y,-p1z)
v21 = (p2z,p2x+i*p2y,E2+m2,0)
v22 = (p2x-i*p2y,-p2z,0,E2+m2)
u31 = (E3+m3,0,p3z,p3x+i*p3y)
u32 = (0,E3+m3,p3x-i*p3y,-p3z)
v41 = (p4z,p4x+i*p4y,E4+m4,0)
v42 = (p4x-i*p4y,-p4z,0,E4+m4)
u1 = (u11,u12)
v2 = (v21,v22)
u3 = (u31,u32)
v4 = (v41,v42)
I = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))
gmunu = ((1,0,0,0),(0,-1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma0 = ((1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma1 = ((0,0,0,1),(0,0,1,0),(0,-1,0,0),(-1,0,0,0))
gamma2 = ((0,0,0,-i),(0,0,i,0),(0,i,0,0),(-i,0,0,0))
gamma3 = ((0,0,1,0),(0,0,0,-1),(-1,0,0,0),(0,1,0,0))
gamma = (gamma0,gamma1,gamma2,gamma3)
pslash1 = dot(p1,gmunu,gamma)
pslash2 = dot(p2,gmunu,gamma)
pslash3 = dot(p3,gmunu,gamma)
pslash4 = dot(p4,gmunu,gamma)
gammaT = transpose(gamma)
bar(u) = dot(conj(u),gamma0)
-- A is the sum over spins
A = sum(s1,1,2,sum(s2,1,2,sum(s3,1,2,sum(s4,1,2,
mag(dot(dot(bar(u3[s3]),gammaT,v4[s4]),gmunu,dot(bar(v2[s2]),gammaT,u1[s1])))^2
))))
-- T1 is the first trace matrix
T1 = contract(dot(pslash1+m1*I,gammaT,pslash2-m2*I,gammaT),1,4)
-- T2 is the second trace matrix
T2 = contract(dot(pslash4-m4*I,gammaT,pslash3+m3*I,gammaT),1,4)
T2 = dot(gmunu,T2,gmunu)
-- B is the product of T1 and T2
B = contract(dot(T1,transpose(T2)))
-- N is the normalization constant
N = (E1+m1)*(E2+m2)*(E3+m3)*(E4+m4)

check(A - N B == 0)
"Circular polarization"
clear
--Simple example of clockwise (right hand) circular polarization.
--Both E and B rotate clockwise while remaining at right angles to each other.
--To see the rotation, suppose you are standing at location z=0 at time t=0.
--You observe E=(0,1,0), that is, E pointing to 12 o'clock.
--Now increase t a little bit by just waiting.
--What happens is the y component decreases and the x component increases.
--So now, instead of pointing straight up, E points to the right a little.
--Keep waiting and eventually observe E=(1,0,0), E pointing to 3 o'clock.
--E has rotated a quarter turn.
--Let t run freely and the rotation continues.
E = (sin(t+z), cos(t+z), 0)
B = (cos(t+z), -sin(t+z), 0)
--Check Maxwell's equations.
check(div(E) = 0)
check(curl(E) + d(B,t) = 0)
check(div(B) = 0)
check(curl(B) - d(E,t) = 0)
check(dot(E,B) = 0)
--Already shown to be true by Maxwell above but do this anyway...
check(dot(E,B) = 0)              --Check right angle
check(dot(E,E) - dot(B,B) = 0)   --Check equal length
"Complex numbers as real vectors"
clear
--Can complex number multiplication be simulated using real vectors?
--Yes, if a rank-3 tensor is used to do the multiply.
A = (AX, AY)
B = (BX, BY)
P = (AX BX - AY BY, AX BY + AY BX) --Complex number product in vector form
T11 = (1, 0)
T12 = (0, 1)
T21 = (0, -1)
T22 = (1, 0)
T = ((T11, T12), (T21, T22))
check(dot(A,T,B) - P = 0)
"Compton scattering demo"

clear

E = sqrt(omega^2 + m^2)

p1 = (omega, 0, 0, omega)

p2 = (E, 0, 0, -omega)

p3 = (omega,
      omega sin(theta) cos(phi),
      omega sin(theta) sin(phi),
      omega cos(theta))

p4 = (E,
      -omega sin(theta) cos(phi),
      -omega sin(theta) sin(phi),
      -omega cos(theta))

u21 = (E + m, 0, p2[4], p2[2] + i p2[3]) / sqrt(E + m)
u22 = (0, E + m, p2[2] - i p2[3], -p2[4]) / sqrt(E + m)

u41 = (E + m, 0, p4[4], p4[2] + i p4[3]) / sqrt(E + m)
u42 = (0, E + m, p4[2] - i p4[3], -p4[4]) / sqrt(E + m)

I = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))

gmunu = ((1,0,0,0),(0,-1,0,0),(0,0,-1,0),(0,0,0,-1))

gamma0 = ((1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma1 = ((0,0,0,1),(0,0,1,0),(0,-1,0,0),(-1,0,0,0))
gamma2 = ((0,0,0,-i),(0,0,i,0),(0,i,0,0),(-i,0,0,0))
gamma3 = ((0,0,1,0),(0,0,0,-1),(-1,0,0,0),(0,1,0,0))

gamma = (gamma0,gamma1,gamma2,gamma3)

gammaT = transpose(gamma)
gammaL = transpose(dot(gmunu,gamma))

u41bar = dot(conj(u41), gamma0) -- adjoint of u41
u42bar = dot(conj(u42), gamma0) -- adjoint of u42

q1 = p1 + p2
q2 = p4 - p1

qslash1 = dot(q1,gmunu,gamma)
qslash2 = dot(q2,gmunu,gamma)

M111 = dot(u41bar, -i e gammaT, qslash1 + m I, -i e gammaT, u21)
M112 = dot(u41bar, -i e gammaT, qslash1 + m I, -i e gammaT, u22)
M121 = dot(u42bar, -i e gammaT, qslash1 + m I, -i e gammaT, u21)
M122 = dot(u42bar, -i e gammaT, qslash1 + m I, -i e gammaT, u22)

M211 = dot(u41bar, -i e gammaT, qslash2 + m I, -i e gammaT, u21)
M212 = dot(u41bar, -i e gammaT, qslash2 + m I, -i e gammaT, u22)
M221 = dot(u42bar, -i e gammaT, qslash2 + m I, -i e gammaT, u21)
M222 = dot(u42bar, -i e gammaT, qslash2 + m I, -i e gammaT, u22)

M11 = contract(dot(M111, gmunu, transpose(conj(M111)), gmunu)) +
      contract(dot(M112, gmunu, transpose(conj(M112)), gmunu)) +
      contract(dot(M121, gmunu, transpose(conj(M121)), gmunu)) +
      contract(dot(M122, gmunu, transpose(conj(M122)), gmunu))

M12 = contract(dot(M111, gmunu, conj(M211), gmunu)) +
      contract(dot(M112, gmunu, conj(M212), gmunu)) +
      contract(dot(M121, gmunu, conj(M221), gmunu)) +
      contract(dot(M122, gmunu, conj(M222), gmunu))

M22 = contract(dot(M211, gmunu, transpose(conj(M211)), gmunu)) +
      contract(dot(M212, gmunu, transpose(conj(M212)), gmunu)) +
      contract(dot(M221, gmunu, transpose(conj(M221)), gmunu)) +
      contract(dot(M222, gmunu, transpose(conj(M222)), gmunu))

pslash2 = dot(p2,gmunu,gamma)
pslash4 = dot(p4,gmunu,gamma)

P2 = pslash2 + m I
P4 = pslash4 + m I

Q1 = qslash1 + m I
Q2 = qslash2 + m I

T = dot(P2,gammaT,Q1,gammaT,P4,gammaL,Q1,gammaL)
f11 = e^4 contract(contract(contract(T,3,4),2,3))

T = dot(P2,gammaT,Q2,gammaT,P4,gammaL,Q1,gammaL)
f12 = e^4 contract(contract(contract(T,3,5),2,3))

T = dot(P2,gammaT,Q2,gammaT,P4,gammaL,Q2,gammaL)
f22 = e^4 contract(contract(contract(T,3,4),2,3))

check(f11 == M11)
check(f12 == M12)
check(f22 == M22)

s = dot(p1 + p2, gmunu, p1 + p2)
t = dot(p1 - p3, gmunu, p1 - p3)
u = dot(p1 - p4, gmunu, p1 - p4)

d11 = (s - m^2)^2
d12 = (s - m^2) (u - m^2)
d22 = (u - m^2)^2

f = (f11/d11 + 2 f12/d12 + f22/d22) / 4

check(f11 == e^4 (-8 s u + 24 s m^2 + 8 u m^2 + 8 m^4))
check(f12 == e^4 (8 s m^2 + 8 u m^2 + 16 m^4))
check(f22 == e^4 (-8 s u + 8 s m^2 + 24 u m^2 + 8 m^4))

p12 = dot(p1,gmunu,p2)
p13 = dot(p1,gmunu,p3)
p14 = dot(p1,gmunu,p4)

check(f11 == e^4 (32 p12 p14 + 64 m^2 p12 - 32 m^2 p13 - 32 m^2 p14 + 32 m^4))
check(f12 == e^4 (16 m^2 p12 - 16 m^2 p14 + 32 m^4))
check(f22 == e^4 (32 p12 p14 + 32 m^2 p12 - 32 m^2 p13 - 64 m^2 p14 + 32 m^4))

check(eval(s,m,0) == 4 omega^2)
check(eval(u,m,0) == -2 omega^2 (cos(theta) + 1))
check(eval(f,m,0) == 2 e^4 ((cos(theta) + 1) / 2 + 2 / (cos(theta) + 1)))

Lambda = ((E/m,0,0,omega/m),(0,1,0,0),(0,0,1,0),(omega/m,0,0,E/m))

p1 = dot(Lambda,p1)
p2 = dot(Lambda,p2)
p3 = dot(Lambda,p3)
p4 = dot(Lambda,p4)

check(s == dot(p1 + p2, gmunu, p1 + p2))
check(t == dot(p1 - p3, gmunu, p1 - p3))
check(u == dot(p1 - p4, gmunu, p1 - p4))

p12 = dot(p1,gmunu,p2)
p13 = dot(p1,gmunu,p3)
p14 = dot(p1,gmunu,p4)

check(f11 == e^4 (32 p12 p14 + 64 m^2 p12 - 32 m^2 p13 - 32 m^2 p14 + 32 m^4))
check(f12 == e^4 (16 m^2 p12 - 16 m^2 p14 + 32 m^4))
check(f22 == e^4 (32 p12 p14 + 32 m^2 p12 - 32 m^2 p13 - 64 m^2 p14 + 32 m^4))

omegaL = dot(p1, (1,0,0,0))
omegaLp = dot(p3, (1,0,0,0))

check(omegaL == omega^2 / m + omega E / m)
check(omegaLp == omega^2 cos(theta) / m + omega E / m)

check(s == m^2 + 2 m omegaL)
check(t == 2 m (omegaLp - omegaL))
check(u == m^2 - 2 m omegaLp)

check(f == 2 e^4 (omegaL/omegaLp + omegaLp/omegaL + (m/omegaL - m/omegaLp + 1)^2 - 1))

R = hbar omega / (m c^2)

omegap = omega / (1 + R (1 - cos(theta)))

f = (omegap / omega)^2 (omega / omegap + omegap / omega - sin(theta)^2)

I = -cos(theta) / R^2 +
    log(1 + R (1 - cos(theta))) (1/R - 2/R^2 - 2/R^3) -
    1 / (2 R (1 + R (1 - cos(theta)))^2) +
    1 / (1 + R (1 - cos(theta))) (-2/R^2 - 1/R^3)

check(f sin(theta) == d(I,theta))
"Dirac equation"

clear

gamma0 = ((1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma1 = ((0,0,0,1),(0,0,1,0),(0,-1,0,0),(-1,0,0,0))
gamma2 = ((0,0,0,-i),(0,0,i,0),(0,i,0,0),(-i,0,0,0))
gamma3 = ((0,0,1,0),(0,0,0,-1),(-1,0,0,0),(0,1,0,0))
omega = sqrt(kx^2 + ky^2 + kz^2 + m^2)
psi1 = (omega+m, 0, kz, kx+i*ky) * exp(i*(kx*x + ky*y + kz*z - omega*t))
psi2 = (0, omega+m, kx-i*ky, -kz) * exp(i*(kx*x + ky*y + kz*z - omega*t))
psi3 = (kz, kx+i*ky, omega-m, 0) * exp(i*(kx*x + ky*y + kz*z - omega*t))
psi4 = (kx-i*ky, -kz, 0, omega-m) * exp(i*(kx*x + ky*y + kz*z - omega*t))
psi5 = (omega-m, 0, kz, kx+i*ky) * exp(-i*(kx*x + ky*y + kz*z - omega*t))
psi6 = (0, omega-m, kx-i*ky, -kz) * exp(-i*(kx*x + ky*y + kz*z - omega*t))
psi7 = (kz, kx+i*ky, omega+m, 0) * exp(-i*(kx*x + ky*y + kz*z - omega*t))
psi8 = (kx-i*ky, -kz, 0, omega+m) * exp(-i*(kx*x + ky*y + kz*z - omega*t))
D(psi) = i*dot(gamma0,d(psi,t)) +
         i*dot(gamma1,d(psi,x)) +
         i*dot(gamma2,d(psi,y)) +
         i*dot(gamma3,d(psi,z)) - m*psi
check(D(psi1)=0)
check(D(psi2)=0)
check(D(psi3)=0)
check(D(psi4)=0)
check(D(psi5)=0)
check(D(psi6)=0)
check(D(psi7)=0)
check(D(psi8)=0)
"Dirac hydrogen atom equation (32)"

-- See "Quantum Mechanics and a Preliminary Investigation of the Hydrogen Atom"

clear

psi(n,m) = 1 / sqrt(pi a0 (n + 1/2)) *
           sqrt((n - abs(m))! / (n + abs(m))!) *
           (2 r / a0 / (n + 1/2))^abs(m) *
           L(2 r / a0 / (n + 1/2), n - abs(m), 2 abs(m)) *
           exp(-r / a0 / (n + 1/2)) *
           exp(i m phi)

a0 = hbar^2 / (k mu)

-- Laguerre polynomial in x (y is a local variable)

L(x,n,a,y) = eval(y^(-a) exp(y) / n! d(exp(-y) y^(n + a), y, n), y, x)

E(n) = -1/2 k^2 mu / hbar^2 / (n + 1/2)^2

psi1 = psi(1,0)
psi2 = psi(2,0)
psi3 = psi(3,0)
psi4 = psi(4,0)

I(f) = do(
  f = defint(f, phi, 0, 2 pi),
  f = integral(f,r),
  0 - eval(f,r,0)
)

R = ((I(conj(psi1) r psi1),
      I(conj(psi1) r psi2),
      I(conj(psi1) r psi3),
      I(conj(psi1) r psi4)),

     (I(conj(psi2) r psi1),
      I(conj(psi2) r psi2),
      I(conj(psi2) r psi3),
      I(conj(psi2) r psi4)),

     (I(conj(psi3) r psi1),
      I(conj(psi3) r psi2),
      I(conj(psi3) r psi3),
      I(conj(psi3) r psi4)),

     (I(conj(psi4) r psi1),
      I(conj(psi4) r psi2),
      I(conj(psi4) r psi3),
      I(conj(psi4) r psi4)))

Enm = ((E(1),0,0,0),
       (0,E(2),0,0),
       (0,0,E(3),0),
       (0,0,0,E(4)))

-- solve for P

P = sqrt(-2 mu / hbar^2 (Enm + k inv(R)))

Pn = P + n hbar unit(4,4)

H(P) = -hbar^2 / (2 mu) inv(dot(P,P))

check(H(Pn) - H(P) ==
hbar^2 / (2 mu) (inv(dot(P,P)) - inv(dot(Pn,Pn))))

check(-hbar^2 / (2 mu) dot(P,P) - k inv(R) == Enm)
"Elliptical polarization"
clear
--Simple example of clockwise (right hand) elliptical polarization.
--As in "circular polarization" except E and B trace out ellipses.
--Becomes linear polarization for EX=0 or EY=0.
--Becomes circular polarization for EX=EY.
--Note that at any given time E and B have the same length.
E = (EX sin(t+z), EY cos(t+z), 0)
B = (EY cos(t+z), -EX sin(t+z), 0)
--Check Maxwell's equations.
check(div(E) = 0)
check(curl(E) + d(B,t) = 0)
check(div(B) = 0)
check(curl(B) - d(E,t) = 0)
check(dot(E,B) = 0)
--Already shown to be true by Maxwell above but do this anyway...
check(dot(E,B) = 0)              --Check right angle
check(dot(E,E) - dot(B,B) = 0)   --Check equal length
"Energy of diagonals"
-- by Calin Barbat

clear

-- See Theorem 2.4 on page 7 from https://arxiv.org/pdf/2012.07835.pdf
-- Proof that the diagonals have the same energy in a certain metric G:
G(v) = ((U1(v[1]) + V1(v[2]), 0), (0, U2(v[1]) + V2(v[2])))

-- diagonals:
d1(t) = (u0, v0) + t * (+alpha, beta)
d2(t) = (u0, v0) + t * (-alpha, beta)

-- calculations:
G1(t) = G(d1(t))
G2(t) = G(d2(t))
v1 = d(d1(t), t)
v2 = d(d2(t), t)
q1(t) = dot(v1, G1(t), v1)
q2(t) = dot(v2, G2(t), v2)

-- check that f1(t) is an odd function:
f1(t) = q1(t) - q2(t)
check(f1(-t) + f1(+t) = 0)

-- qed:
-- "The diagonals have the same energy."
"Gordon decomposition"

clear

E1 = sqrt(p1x^2 + p1y^2 + p1z^2 + m^2)
E2 = sqrt(p2x^2 + p2y^2 + p2z^2 + m^2)
p1 = (E1,p1x,p1y,p1z)
p2 = (E2,p2x,p2y,p2z)
u11 = (E1+m,0,p1z,p1x+i*p1y)
u12 = (0,E1+m,p1x-i*p1y,-p1z)
u21 = (E2+m,0,p2z,p2x+i*p2y)
u22 = (0,E2+m,p2x-i*p2y,-p2z)
u1 = (u11,u12)
u2 = (u21,u22)
I = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))
gmunu = ((1,0,0,0),(0,-1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma0 = ((1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma1 = ((0,0,0,1),(0,0,1,0),(0,-1,0,0),(-1,0,0,0))
gamma2 = ((0,0,0,-i),(0,0,i,0),(0,i,0,0),(-i,0,0,0))
gamma3 = ((0,0,1,0),(0,0,0,-1),(-1,0,0,0),(0,1,0,0))
gamma = (gamma0,gamma1,gamma2,gamma3)
T = transpose(dot(gamma,transpose(gamma)),2,3)
sigmamunu = i/2 * (T - transpose(T))
for(s1,1,2,for(s2,1,2,for(mu,1,4,
  T = ((p2+p1)[mu] I + i dot(p2-p1,gmunu,sigmamunu[mu])) / (2 m),
  A = dot(conj(u2[s2]),gamma0,T,u1[s1]),
  B = dot(conj(u2[s2]),gamma0,gamma[mu],u1[s1]),
  check(A=B)
)))
"Green's theorem"

clear
P = 2x^3 - y^3
Q = x^3 + y^3
f = d(Q,x) - d(P,y)
x = r cos(theta)
y = r sin(theta)
T = defint(f r,r,0,1,theta,0,2pi)
check(T = 3/2 pi)

clear
x = cos(t)
y = sin(t)
P = 2x^3 - y^3
Q = x^3 + y^3
f = P d(x,t) + Q d(y,t)
f = circexp(f)
T = defint(f,t,0,2pi)
check(T = 3/2 pi)

clear
P = 1 - y
Q = x
x = 2 cos(t)
y = 2 sin(t)
T = defint(P d(x,t) + Q d(y,t),t,0,2pi)
check(T = 8 pi)

x = quote(x) --clear x
y = quote(y) --clear y
h = sqrt(4 - x^2)
T = defint(d(Q,x) - d(P,y),y,-h,h,x,-2,2)
check(T = 8 pi)

f = d(Q,x) - d(P,y) -- do before change of coordinates
x = r cos(theta)
y = r sin(theta)
T = defint(f r,r,0,2,theta,0,2pi)
check(T = 8 pi)

T = defint(f r,theta,0,2pi,r,0,2) -- try integrating over theta first
check(T = 8 pi)
"Hydrogen atom"

clear

psi(n,l,m) = R(n,l) Y(l,m)

R(n,l) = 2 / (n^2 a0^(3/2)) *
         sqrt((n - l - 1)! / (n + l)!) *
         (2 rho / n)^l *
         L(2 rho / n,n - l - 1,2 l + 1) *
         exp(-rho / n)

L(x,n,m) = (n + m)! sum(k,0,n,(-x)^k / ((n - k)! (m + k)! k!))

rho = r / a0

a0 = 4 pi epsilon0 hbar^2 / (e^2 mu)

Y(l,m) = (-1)^m sqrt((2l + 1) / (4 pi) (l - m)! / (l + m)!) *
         P(l,m) exp(i m phi)

-- associated legendre of cos theta

P(l,m) = test(m < 0, (-1)^m (l + m)! / (l - m)! P(l,-m),
         1 / (2^l l!) sin(theta)^m *
         eval(d((x^2 - 1)^l,x,l + m),x,cos(theta)))

H(psi) = -hbar^2 Lap(psi) / (2 mu) - e^2 / (4 pi epsilon0 r) psi

Lap(f) = 1/r^2 d(r^2 d(f,r),r) +
         1/(r^2 sin(theta)) d(sin(theta) d(f,theta),theta) +
         1/(r sin(theta))^2 d(f,phi,2)

E(n) = -mu / (2 n^2) (e^2 / (4 pi epsilon0 hbar))^2

check(H(psi(1,0,0)) == E(1) psi(1,0,0))

check(H(psi(2,0,0)) == E(2) psi(2,0,0))
check(H(psi(2,1,0)) == E(2) psi(2,1,0))
check(H(psi(2,1,1)) == E(2) psi(2,1,1))
check(H(psi(2,1,-1)) == E(2) psi(2,1,-1))

check(H(psi(3,0,0)) == E(3) psi(3,0,0))
check(H(psi(3,1,0)) == E(3) psi(3,1,0))
check(H(psi(3,1,1)) == E(3) psi(3,1,1))
check(H(psi(3,1,-1)) == E(3) psi(3,1,-1))
check(H(psi(3,2,0)) == E(3) psi(3,2,0))
check(H(psi(3,2,1)) == E(3) psi(3,2,1))
check(H(psi(3,2,-1)) == E(3) psi(3,2,-1))
check(H(psi(3,2,2)) == E(3) psi(3,2,2))
check(H(psi(3,2,-2)) == E(3) psi(3,2,-2))

for(n,1,3,for(l,0,n - 1,for(m,-l,l,check(H(psi(n,l,m)) == E(n) psi(n,l,m)))))
"Laguerre function"

clear

L(x,n,m) = (n + m)! sum(k,0,n,(-x)^k / ((n - k)! (m + k)! k!))

check(L(x,1,0) == laguerre(x,1,0))
check(L(x,2,0) == laguerre(x,2,0))
check(L(x,2,1) == laguerre(x,2,1))
check(L(x,3,0) == laguerre(x,3,0))
check(L(x,3,1) == laguerre(x,3,1))
check(L(x,3,2) == laguerre(x,3,2))
"Legendre function"

clear

P(x,l,m) = 1 / (2^l l!) (1 - x^2)^(m / 2) d((x^2 - 1)^l,x,l + m)

check(P(x,0,0) == 1)
check(P(x,1,0) == x)
check(P(x,1,1) == sqrt(1 - x^2))
check(P(x,1,-1) == -1/2 sqrt(1 - x^2))
check(P(x,2,0) == 1/2 (3 x^2 - 1))
check(P(x,2,1) == 3 x sqrt(1 - x^2))
check(P(x,2,-1) == -1/2 x sqrt(1 - x^2))
check(P(x,2,2) == 3 (1 - x^2))
check(P(x,2,-2) == 1/8 (1 - x^2))

clear

P(x,l,m) = eval(1/(2^l l!) (1 - y^2)^(m/2) d((y^2 - 1)^l,y,l + m),y,x)

check(legendre(x,0,0) == 1)
check(legendre(x,1,0) == x)
check(legendre(x,1,1) == sqrt(1 - x^2))
check(legendre(x,1,-1) == -1/2 sqrt(1 - x^2))
check(legendre(x,2,0) == 1/2 (3 x^2 - 1))
check(legendre(x,2,1) == 3 x sqrt(1 - x^2))
check(legendre(x,2,-1) == -1/2 x sqrt(1 - x^2))
check(legendre(x,2,2) == 3 (1 - x^2))
check(legendre(x,2,-2) == 1/8 (1 - x^2))

check(P(x,0,0) == legendre(x,0,0))
check(P(x,1,0) == legendre(x,1,0))
check(P(x,1,1) == legendre(x,1,1))
check(P(x,1,-1) == legendre(x,1,-1))
check(P(x,2,0) == legendre(x,2,0))
check(P(x,2,1) == legendre(x,2,1))
check(P(x,2,2) == legendre(x,2,2))
check(P(x,2,-1) == legendre(x,2,-1))
check(P(x,2,-2) == legendre(x,2,-2))

check(P(expcos(theta),0,0) == legendre(expcos(theta),0,0))
check(P(expcos(theta),1,0) == legendre(expcos(theta),1,0))
check(P(expcos(theta),1,1) == legendre(expcos(theta),1,1))
check(P(expcos(theta),1,-1) == legendre(expcos(theta),1,-1))
check(P(expcos(theta),2,0) == legendre(expcos(theta),2,0))
check(P(expcos(theta),2,1) == legendre(expcos(theta),2,1))
check(P(expcos(theta),2,2) == legendre(expcos(theta),2,2))
check(P(expcos(theta),2,-1) == legendre(expcos(theta),2,-1))
check(P(expcos(theta),2,-2) == legendre(expcos(theta),2,-2))
"Maxwell in tensor form"

clear

--Maxwell equations in tensor form.
--See the book Gravitation p. 81.
--
--   F     + F     + F     = 0
--    ab,c    bc,a    ca,b
--
--    ab           a
--   F     = 4 pi J
--      ,b
--
--For this demo, use circular polarized light.
--
EX = sin(t+z)
EY = cos(t+z)
EZ = 0
BX = cos(t+z)
BY = -sin(t+z)
BZ = 0
FDD = ((  0, -EX, -EY, -EZ),
       ( EX,   0,  BZ, -BY),
       ( EY, -BZ,   0,  BX),
       ( EZ,  BY, -BX,   0))   --See p. 74. Here, DD means "down down" indices.
X = (t,x,y,z)   --Coordinate system
FDDD = d(FDD,X)   --Gradient of F
T1 = transpose(transpose(FDDD,2,3),1,2)   --Transpose bca to abc
T2 = transpose(transpose(FDDD,1,2),2,3)   --Transpose cab to abc
check(FDDD + T1 + T2 = 0)
guu = ((-1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))
FDDU = contract(outer(FDDD,guu),3,4)   --Easier to make FDDU than FUUD.
check(contract(FDDU,2,3) = 0)   --For light J is zero.
"Moller scattering demo"

clear

-- Verify formulas for Moller scattering

E = sqrt(p^2 + m^2)

p1 = (E, 0, 0, p)
p2 = (E, 0, 0, -p)

p3 = (E,
      p expsin(theta) expcos(phi),
      p expsin(theta) expsin(phi),
      p expcos(theta))

p4 = (E,
      -p expsin(theta) expcos(phi),
      -p expsin(theta) expsin(phi),
      -p expcos(theta))

-- spinors

N = (E + m)^4

u11 = (E + m, 0, p1[4], p1[2] + i p1[3])
u12 = (0, E + m, p1[2] - i p1[3], -p1[4])

u21 = (E + m, 0, p2[4], p2[2] + i p2[3])
u22 = (0, E + m, p2[2] - i p2[3], -p2[4])

u31 = (E + m, 0, p3[4], p3[2] + i p3[3])
u32 = (0, E + m, p3[2] - i p3[3], -p3[4])

u41 = (E + m, 0, p4[4], p4[2] + i p4[3])
u42 = (0, E + m, p4[2] - i p4[3], -p4[4])

u1 = (u11,u12)
u2 = (u21,u22)
u3 = (u31,u32)
u4 = (u41,u42)

I = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))

gmunu = ((1,0,0,0),(0,-1,0,0),(0,0,-1,0),(0,0,0,-1))

gamma0 = ((1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma1 = ((0,0,0,1),(0,0,1,0),(0,-1,0,0),(-1,0,0,0))
gamma2 = ((0,0,0,-i),(0,0,i,0),(0,i,0,0),(-i,0,0,0))
gamma3 = ((0,0,1,0),(0,0,0,-1),(-1,0,0,0),(0,1,0,0))

gamma = (gamma0,gamma1,gamma2,gamma3)

gammaT = transpose(gamma)
gammaL = transpose(dot(gmunu,gamma))

u3bar = dot(conj(u3),gamma0) -- adjoint of u3
u4bar = dot(conj(u4),gamma0) -- adjoint of u4

w31 = zero(2,2,4)
w42 = zero(2,2,4)
w41 = zero(2,2,4)
w32 = zero(2,2,4)

for(a,1,2, for(b,1,2,
 w31[a,b] = dot(u3bar[a], gammaT, u1[b]),
 w42[a,b] = dot(u4bar[a], gammaL, u2[b]),
 w41[a,b] = dot(u4bar[a], gammaT, u1[b]),
 w32[a,b] = dot(u3bar[a], gammaL, u2[b])
))

-- matrix elements

a1 = zero(2,2,2,2)
a2 = zero(2,2,2,2)

for(a,1,2, for(b,1,2, for(c,1,2, for(d,1,2,
 a1[a,b,c,d] = dot(w31[c,a], w42[d,b]),
 a2[a,b,c,d] = dot(w41[d,a], w32[c,b])
))))

-- "Sum over spin states"

a11 = sum(conj(a1) a1)
a12 = sum(conj(a2) a1)
a22 = sum(conj(a2) a2)

S = a11 - a12 - conj(a12) + a22
-- S

-- "Verify Casimir trick"

pslash1 = dot(p1,gmunu,gamma)
pslash2 = dot(p2,gmunu,gamma)
pslash3 = dot(p3,gmunu,gamma)
pslash4 = dot(p4,gmunu,gamma)

X1 = pslash1 + m I
X2 = pslash2 + m I
X3 = pslash3 + m I
X4 = pslash4 + m I

T1 = contract(dot(X3,gammaT,X1,gammaT),1,4)
T2 = contract(dot(X4,gammaL,X2,gammaL),1,4)
f11 = contract(dot(T1,transpose(T2)))

T = contract(dot(X3,gammaT,X1,gammaT,X4,gammaL,X2,gammaL),1,6)
f12 = contract(contract(T,1,3))

T1 = contract(dot(X4,gammaT,X1,gammaT),1,4)
T2 = contract(dot(X3,gammaL,X2,gammaL),1,4)
f22 = contract(dot(T1,transpose(T2)))

check(f11 == a11 / N)
check(f12 == a12 / N)
check(f22 == a22 / N)

-- "ok"

-- "Verify Mandelstam formulas"

s = dot(p1 + p2, gmunu, p1 + p2)
t = dot(p1 - p3, gmunu, p1 - p3)
u = dot(p1 - p4, gmunu, p1 - p4)

d11 = t^2
d12 = t u
d22 = u^2

f = (f11/d11 - 2 f12/d12 + f22/d22) / 4

check(f11 == 8 s^2 + 8 u^2 - 64 s m^2 - 64 u m^2 + 192 m^4)
check(f12 == -8 s^2 + 64 s m^2 - 96 m^4)
check(f22 == 8 s^2 + 8 t^2 - 64 s m^2 - 64 t m^2 + 192 m^4)

-- "ok"

-- "Verify probability density"

p12 = dot(p1, gmunu, p2)
p13 = dot(p1, gmunu, p3)
p14 = dot(p1, gmunu, p4)

check(f11 == 32 p12^2 + 32 p14^2 - 64 m^2 p13 + 64 m^4)
check(f12 == -32 p12^2 + 32 m^2 p12 + 32 m^2 p13 + 32 m^2 p14 - 32 m^4)
check(f22 == 32 p12^2 + 32 p13^2 - 64 m^2 p14 + 64 m^4)

-- "ok"

-- "Verify probability density for m = 0"

m = 0

check(s == 4 E^2)
check(t == 2 E^2 (expcos(theta) - 1))
check(u == -2 E^2 (expcos(theta) + 1))

check(f == 4 (expcos(theta)^2 + 3)^2 / (expcos(theta)^2 - 1)^2)

-- Zee formula

g = 2 ((1 + expcos(theta/2)^4) / expsin(theta/2)^4 +
    2 / (expsin(theta/2)^2 expcos(theta/2)^2) +
    (1 + expsin(theta/2)^4) / expcos(theta/2)^4)

check(f == g)

m = quote(m) -- undo m = 0

-- "ok"
"Muon decay demo"

clear

-- Verify muon decay formulas

p1x = 0 -- muon rest frame
p1y = 0
p1z = 0

E1 = sqrt(p1x^2 + p1y^2 + p1z^2 + m1^2)
E2 = sqrt(p2x^2 + p2y^2 + p2z^2 + m2^2)
E3 = sqrt(p3x^2 + p3y^2 + p3z^2 + m3^2)
E4 = sqrt(p4x^2 + p4y^2 + p4z^2 + m4^2)

p1 = (E1, p1x, p1y, p1z) -- muon
p2 = (E2, p2x, p2y, p2z) -- muon neutrino
p3 = (E3, p3x, p3y, p3z) -- electron antineutrino
p4 = (E4, p4x, p4y, p4z) -- electron

-- spinors

N = (E1 + m1) (E2 + m2) (E3 + m3) (E4 + m4)

u11 = (E1 + m1, 0, p1z, p1x + i p1y)
u12 = (0, E1 + m1, p1x - i p1y, -p1z)

u21 = (E2 + m2, 0, p2z, p2x + i p2y)
u22 = (0, E2 + m2, p2x - i p2y, -p2z)

v31 = (p3z, p3x + i p3y, E3 + m3, 0)
v32 = (p3x - i p3y, -p3z, 0, E3 + m3)

u41 = (E4 + m4, 0, p4z, p4x + i p4y)
u42 = (0, E4 + m4, p4x - i p4y, -p4z)

u1 = (u11,u12) -- muon
u2 = (u21,u22) -- muon neutrino
v3 = (v31,v32) -- electron antineutrino
u4 = (u41,u42) -- electron

I = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))

gmunu = ((1,0,0,0),(0,-1,0,0),(0,0,-1,0),(0,0,0,-1))

gamma0 = ((1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma1 = ((0,0,0,1),(0,0,1,0),(0,-1,0,0),(-1,0,0,0))
gamma2 = ((0,0,0,-i),(0,0,i,0),(0,i,0,0),(-i,0,0,0))
gamma3 = ((0,0,1,0),(0,0,0,-1),(-1,0,0,0),(0,1,0,0))
gamma5 = i dot(gamma0,gamma1,gamma2,gamma3)

gamma = (gamma0,gamma1,gamma2,gamma3)

u2bar = dot(conj(u2),gamma0) -- adjoint of u2
u4bar = dot(conj(u4),gamma0) -- adjoint of u4

-- transpose to put 1st index in the middle

X = transpose(dot(gamma, I - gamma5))

w21 = zero(2,2,4)
w43 = zero(2,2,4)

for(a,1,2, for(b,1,2,
 w21[a,b] = dot(u2bar[a], X, u1[b]),
 w43[a,b] = dot(u4bar[a], X, v3[b])
))

-- matrix elements

M = zero(2,2,2,2)

for(a,1,2, for(b,1,2, for(c,1,2, for(d,1,2,
 M[a,b,c,d] = dot(w43[d,c], gmunu, w21[b,a])
))))

-- "Sum over spin states"

S = sum(conj(M) M)
-- S

-- "Verify Casimir trick"

pslash1 = dot(p1,gmunu,gamma)
pslash2 = dot(p2,gmunu,gamma)
pslash3 = dot(p3,gmunu,gamma)
pslash4 = dot(p4,gmunu,gamma)

T1 = contract(dot(pslash4, X, pslash3, X), 1,4)
T2 = contract(dot(pslash2, X, pslash1, X), 1,4)
T = contract(dot(T1, gmunu, transpose(T2), gmunu))

check(T == S/N)

-- "ok"

-- "Verify probability density"

check(1/4 T == 64 dot(p1,gmunu,p3) dot(p2,gmunu,p4))

-- "ok"

-- Compute muon lifetime

GF = 1.1663787 10^(-5) GeV^(-2)
mmu = 1.883531627 10^(-28) kilogram
h = 6.62607015 10^(-34) joule second
c = 299792458 meter / second

joule = kilogram meter^2 / second^2
GeV = 10^9 1.602176634 10^(-19) joule

kilogram = "kilogram"
meter = "meter"
second = "second"

-- "Muon lifetime"

check(infixform(float(96 pi^2 h / (GF^2 (mmu c^2)^5))) == "2.18735 10^(-6) second")
"Muon production demo"

clear

-- Verify formulas for muon pair production

p = sqrt(E^2 - m^2)

rho = sqrt(E^2 - M^2)

p1 = (E, 0, 0, p)
p2 = (E, 0, 0, -p)

p3 = (E,
      rho expsin(theta) expcos(phi),
      rho expsin(theta) expsin(phi),
      rho expcos(theta))

p4 = (E,
      -rho expsin(theta) expcos(phi),
      -rho expsin(theta) expsin(phi),
      -rho expcos(theta))

-- spinors

N = (E + m)^2 (E + M)^2

u11 = (E + m, 0, p1[4], p1[2] + i p1[3])
u12 = (0, E + m, p1[2] - i p1[3], -p1[4])

v21 = (p2[4], p2[2] + i p2[3], E + m, 0)
v22 = (p2[2] - i p2[3], -p2[4], 0, E + m)

u31 = (E + M, 0, p3[4], p3[2] + i p3[3])
u32 = (0, E + M, p3[2] - i p3[3], -p3[4])

v41 = (p4[4], p4[2] + i p4[3], E + M, 0)
v42 = (p4[2] - i p4[3], -p4[4], 0, E + M)

u1 = (u11,u12)
v2 = (v21,v22)
u3 = (u31,u32)
v4 = (v41,v42)

I = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))

gmunu = ((1,0,0,0),(0,-1,0,0),(0,0,-1,0),(0,0,0,-1))

gamma0 = ((1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma1 = ((0,0,0,1),(0,0,1,0),(0,-1,0,0),(-1,0,0,0))
gamma2 = ((0,0,0,-i),(0,0,i,0),(0,i,0,0),(-i,0,0,0))
gamma3 = ((0,0,1,0),(0,0,0,-1),(-1,0,0,0),(0,1,0,0))

gamma = (gamma0,gamma1,gamma2,gamma3)

gammaT = transpose(gamma)
gammaL = transpose(dot(gmunu,gamma))

v2bar = dot(conj(v2),gamma0) -- adjoint of v2
u3bar = dot(conj(u3),gamma0) -- adjoint of u3

w21 = zero(2,2,4)
w34 = zero(2,2,4)

for(a,1,2, for(b,1,2,
 w21[a,b] = dot(v2bar[a], gammaT, u1[b]),
 w34[a,b] = dot(u3bar[a], gammaL, v4[b])
))

-- matrix elements (use MX, M is used for muon mass)

MX = zero(2,2,2,2)

for(a,1,2, for(b,1,2, for(c,1,2, for(d,1,2,
 MX[a,b,c,d] = dot(w21[b,a], w34[c,d])
))))

-- "Sum over spin states"

S = sum(conj(MX) MX)
-- S

-- "Verify Casimir trick"

pslash1 = dot(p1,gmunu,gamma)
pslash2 = dot(p2,gmunu,gamma)
pslash3 = dot(p3,gmunu,gamma)
pslash4 = dot(p4,gmunu,gamma)

X1 = pslash1 + m I
X2 = pslash2 - m I
X3 = pslash3 + M I
X4 = pslash4 - M I

T1 = contract(dot(X3,gammaT,X4,gammaT),1,4)
T2 = contract(dot(X2,gammaL,X1,gammaL),1,4)

f = contract(dot(T1,transpose(T2)))

check(f == S/N)

-- "ok"

-- "Verify Mandelstam formula"

s = dot(p1 + p2, gmunu, p1 + p2)
t = dot(p1 - p3, gmunu, p1 - p3)
u = dot(p1 - p4, gmunu, p1 - p4)

check(f == 16 t^2 - 16 s u + 32 u (m^2 + M^2) - 8 s^2 +
           64 M^2 s + 64 m^2 s - 48 (m^2 + M^2)^2)

-- "ok"

-- "Verify probability density"

p12 = dot(p1,gmunu,p2)
p13 = dot(p1,gmunu,p3)
p14 = dot(p1,gmunu,p4)
p23 = dot(p2,gmunu,p3)
p24 = dot(p2,gmunu,p4)
p34 = dot(p3,gmunu,p4)

check(f == 32 p13 p24 + 32 p14 p23 + 32 m^2 p34 + 32 M^2 p12 + 64 M^2 m^2)

-- "ok"
"Quantum electric field"

clear

-- derived units
joule = kilogram * meter^2 * second^(-2)
volt = kilogram * meter^2 * second^(-3) * ampere^(-1)
farad = kilogram^(-1) * meter^(-2) * second^4 * ampere^2
-- physical values
hbar = 1.054572 * 10^(-34) * joule * second
epsilon0 = 8.854188 * 10^(-12) * farad * meter^(-1)
c = 299792458 * meter * second^(-1)
lambda = 600 * 10^(-9) * meter
omega = 2 * float(pi) * c / lambda
-- conversion constant
C = sqrt(0.5 * hbar * omega * epsilon0^(-1) * meter^(-3))
check(infixform(C) == "0.000136733 kilogram meter / (ampere second^3)")
check(infixform(volt * meter^(-1)) == "kilogram meter / (ampere second^3)")
"Quantum electrodynamics"

clear

-- This script does a few of the exercises from Feynman's book "Quantum Electrodynamics."

-- Define the spacetime metric (for multiplying spacetime vectors).

metric = ((-1, 0, 0, 0),
          ( 0,-1, 0, 0),
          ( 0, 0,-1, 0),
          ( 0, 0, 0, 1))

-- Define I, the identity matrix.

I = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))

-- Define the gamma matrices.

gammax = (( 0, 0, 0, 1),
          ( 0, 0, 1, 0),
          ( 0,-1, 0, 0),
          (-1, 0, 0, 0))

gammay = (( 0, 0, 0,-i),
          ( 0, 0, i, 0),
          ( 0, i, 0, 0),
          (-i, 0, 0, 0))

gammaz = (( 0, 0, 1, 0),
          ( 0, 0, 0,-1),
          (-1, 0, 0, 0),
          ( 0, 1, 0, 0))

gammat = (( 1, 0, 0, 0),
          ( 0, 1, 0, 0),
          ( 0, 0,-1, 0),
          ( 0, 0, 0,-1))

-- Define the gamma vector.
--
-- The gamma vector has gamma matrices for its components. We express it here
-- as a rank 3 tensor. We set up the tensor so that the vector component index
-- is the last (rightmost) index. With this configuration we can left-multiply
-- with a Feynman slash matrix using the dot function.
--
-- For example, in component notation, this is how we want to multiply with a
-- Feynman slash matrix:
--
--     aslash[a,b] gamma[b,c,d]
--
-- (summation over the repeated index b)
--
-- The summation over b is exactly what the dot function does so we can do the
-- above multiply with dot(aslash,gamma).
--
-- In the following outer products, placing the basis vector operands on the
-- right-hand side results in the desired index ordering.

gamma = outer(gammax,(1,0,0,0)) +
        outer(gammay,(0,1,0,0)) +
        outer(gammaz,(0,0,1,0)) +
        outer(gammat,(0,0,0,1))

-- DOT is for multiplying gamma vectors. This is a special multiply because we
-- have to dot the individual vector components (the gamma matrices) then we
-- have to sum over all the results. In component notation, this is how we want
-- to do the multiply:
--
--     T[a,c] = A[a,b,d] * B[b,c,d]
--
-- To do this, we start with an outer product which results in the following
-- rank 6 tensor:
--
--     T[a,b,d,b,c,d]
--
-- Next we sum over b (indices 2 and 4) to get the following:
--
--     T[a,d,c,d]
--
-- Then we sum over d (indices 2 and 4 again) to get
--
--     T[a,c]
--
-- One final note, dot(B,metric) applies the spacetime metric to the rightmost
-- index of B, the vector index.

DOT(A,B) = contract(contract(outer(A,dot(B,metric)),2,4),2,4)

-- Define arbitrary spacetime vectors a, b and c.

a = (ax,ay,az,at)
b = (bx,by,bz,bt)
c = (cx,cy,cz,ct)

-- Define generic Feynman slash matrices.
-- Note: The order of dot operands here is different from the book. This is
-- because we defined gamma to have its vector index on the right. Therefore
-- we have to right-multiply with the spacetime vector so that dot contracts
-- over the correct indices. In component notation we have
--
--     aslash[u,v] = gamma[u,v,w] * a[w]
--
-- where summation is over the repeated index w.

aslash = dot(gamma,metric,a)
bslash = dot(gamma,metric,b)
cslash = dot(gamma,metric,c)

-- The Feynman slash matrices are 4x4 matrices. For example, aslash looks like
-- this:
--
--     at           0           -az       -ax + i ay
--
--     0            at       -ax - i ay       az
--
--     az       ax - i ay       -at           0
--
-- ax + i ay       -az           0           -at

-- Now we are ready to try the exercises. We want to show that each of the
-- following identities is true.

--------------------------------------------------------------------------------
--
--     aslash = at gammat - ax gammax - ay gammay - az gammaz
--
--------------------------------------------------------------------------------

A = aslash

B = at gammat - ax gammax - ay gammay - az gammaz

check(A = B) -- if A = B then continue, else stop

--------------------------------------------------------------------------------
--
--     aslash bslash = -bslash aslash + 2 a b
--
--------------------------------------------------------------------------------

A = dot(aslash,bslash)

B = -dot(bslash,aslash) + 2 dot(a,metric,b) I

check(A = B)

--------------------------------------------------------------------------------
--
--     gamma gamma = 4
--
--------------------------------------------------------------------------------

A = DOT(gamma,gamma)

B = 4 I

check(A = B)

--------------------------------------------------------------------------------
--
--     gamma aslash gamma = -2 aslash
--
--------------------------------------------------------------------------------

A = DOT(gamma,dot(aslash,gamma))

B = -2 aslash

check(A = B)

--------------------------------------------------------------------------------
--
--     gamma aslash bslash gamma = 4 a b
--
--------------------------------------------------------------------------------

A = DOT(gamma,dot(aslash,bslash,gamma))

B = 4 dot(a,metric,b) I

check(A = B)

--------------------------------------------------------------------------------
--
--     gamma aslash bslash cslash gamma = -2 cslash bslash aslash
--
--------------------------------------------------------------------------------

A = DOT(gamma,dot(aslash,bslash,cslash,gamma))

B = -2 dot(cslash,bslash,aslash)

check(A = B)

--------------------------------------------------------------------------------
--
--     If we get here then everything worked.
--
--------------------------------------------------------------------------------
"Quantum harmonic oscillator"

clear

# Ref. "Quantum harmonic oscillator" in Wikipedia

# Compute psi_n(x) for n = 3

n = 3
m = hbar / omega
X = sqrt(m * omega / hbar) * x
H = (-1)^n * exp(X^2) * d(exp(-X^2),n)
C = (m * omega / pi / hbar)^(1/4) / sqrt(2^n * n!)
psi = C * exp(-m * omega * x^2 / 2 / hbar) * H

# Define a function to integrate f(x) numerically

d = 1/10
summa(f) = float(d*sum(k,-50,50,eval(f,x,d*k)))

-- Check normalization
check(infixform(summa(psi * psi)) == "1")

-- Expectation value for position
check(infixform(summa(psi * x * psi)) == "0")

-- Expectation value for momentum
check(infixform(summa(psi * (-i * hbar) * d(psi,x))) == "0")

-- Expectation value for kinetic energy
K = psi * (-hbar^2 / 2 / m) * d(psi,x,2)
check(infixform(summa(K)) == "1.75 hbar omega")

-- Expectation value for potential energy
V = psi * (m * omega^2 / 2) * x^2 * psi
check(infixform(summa(V)) == "1.75 hbar omega")

-- Expectation value for Hamiltonian (total energy)
check(infixform(summa(K + V)) == "3.5 hbar omega")

-- Energy eigenvalue
check(infixform(hbar * omega * (n + 0.5)) == "3.5 hbar omega")
"Radial eigenfunctions"

clear

e = quote(e)

R(n,l) = 2 / (n^2 a0^(3/2)) *
         sqrt((n - l - 1)! / (n + l)!) *
         (2 rho / n)^l *
         L(2 rho / n,n - l - 1,2 l + 1) *
         exp(-rho / n)

L(x,n,m) = (n + m)! sum(k,0,n,(-x)^k / ((n - k)! (m + k)! k!))

rho = r / a0
A = a0^(3/2)

check(R(1,0) A == 2 exp(-rho))
check(R(2,0) A == sqrt(2)/4 (2 - rho) exp(-rho/2))
check(R(2,1) A == sqrt(6)/12 rho exp(-rho/2))
check(R(3,0) A == 2 sqrt(3)/27 (3 - 2 rho + 2/9 rho^2) exp(-rho/3))
check(R(3,1) A == sqrt(6)/81 rho (4 - 2/3 rho) exp(-rho/3))
check(R(3,2) A == 2 sqrt(30)/1215 rho^2 exp(-rho/3))
"Rotation matrix"

clear

-- This script demonstrates some properties of a rotation matrix.

-- These are the matrix components.

R11 = expcos(phi2) expcos(phi1) - expcos(theta) expsin(phi1) expsin(phi2)
R12 = -expcos(phi2) expsin(phi1) - expcos(theta) expcos(phi1) expsin(phi2)
R13 = expsin(phi2) expsin(theta)

R21 = expsin(phi2) expcos(phi1) + expcos(theta) expsin(phi1) expcos(phi2)
R22 = -expsin(phi2) expsin(phi1) + expcos(theta) expcos(phi1) expcos(phi2)
R23 = -expcos(phi2) expsin(theta)

R31 = expsin(theta) expsin(phi1)
R32 = expsin(theta) expcos(phi1)
R33 = expcos(theta)

-- R is a rotation matrix.

R = ((R11,R12,R13),(R21,R22,R23),(R31,R32,R33))

-- Inverse and transpose are equivalent.

check(inv(R) = transpose(R))

-- Determinant is 1.

check(det(R) = 1)

-- Does not change the length of a vector.

U = (U1,U2,U3)

check(abs(U) = abs(dot(R,U)))
"Rutherford scattering demo"

clear

-- Verify formulas for Rutherford scattering

E = sqrt(p^2 + m^2)

p1 = (E, 0, 0, p)

p2 = (E,
      p expsin(theta) expcos(phi),
      p expsin(theta) expsin(phi),
      p expcos(theta))

-- spinors

N = (E + m)^2

u11 = (E + m, 0, p1[4], p1[2] + i p1[3])
u12 = (0, E + m, p1[2] - i p1[3], -p1[4])

u21 = (E + m, 0, p2[4], p2[2] + i p2[3])
u22 = (0, E + m, p2[2] - i p2[3], -p2[4])

u1 = (u11,u12)
u2 = (u21,u22)

I = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))

gmunu = ((1,0,0,0),(0,-1,0,0),(0,0,-1,0),(0,0,0,-1))

gamma0 = ((1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma1 = ((0,0,0,1),(0,0,1,0),(0,-1,0,0),(-1,0,0,0))
gamma2 = ((0,0,0,-i),(0,0,i,0),(0,i,0,0),(-i,0,0,0))
gamma3 = ((0,0,1,0),(0,0,0,-1),(-1,0,0,0),(0,1,0,0))

gamma = (gamma0,gamma1,gamma2,gamma3)

u2bar = dot(conj(u2),gamma0) -- adjoint of u2

-- matrix elements

M = zero(2,2)

for(a,1,2, for(b,1,2,
 M[a,b] = dot(u2bar[b], gamma0, u1[a])
))

-- "Sum over spin states"

S = sum(conj(M) M)
-- S

-- "Verify Casimir trick"

pslash1 = dot(p1,gmunu,gamma)
pslash2 = dot(p2,gmunu,gamma)

T = contract(dot(pslash2 + m I, gamma0, pslash1 + m I, gamma0))

check(T == S/N)

-- "ok"

-- "Verify probability density"

check(T == 4 E^2 + 4 m^2 + 4 p^2 expcos(theta))

-- "ok"

-- "Verify additional formulas"

q = p1 - p2
q4 = dot(q,gmunu,q)^2

check(q4 == 16 p^4 expsin(theta/2)^4)
check(q4 == 4 p^4 (expcos(theta) - 1)^2)

-- "ok"
"Schwarzchild metric"

clear

gdd = ((-F(r),      0,   0,                0),
       (    0, 1/F(r),   0,                0),
       (    0,      0, r^2,                0),
       (    0,      0,   0, r^2*sin(theta)^2))

-- Note: "dd" stands for two "down" indices, "uu" stands for two "up" indices.

-- X is for computing gradients.

X = (t,r,theta,phi)

-- Step 1: Calculate guu.

guu = inv(gdd)

-- Step 2: Calculate the connection coefficients. ("Gravitation" by MTW p. 210)
--
-- Gamma    = 1/2 (g     + g     - g    )
--      abc         ab,c    ac,b    bc,a
--
-- Note: The comma means gradient which increases the rank of gdd by 1.

gddd = d(gdd,X)

-- Transpose indices to match abc.

GAMDDD = 1/2 * (gddd +              -- indices are already in correct order
transpose(gddd,2,3) -               -- transpose c and b
transpose(transpose(gddd,2,3),1,2)) -- transpose c and a, then b and a

-- Raise first index.
--
--      a      au
-- Gamma    = g   Gamma
--       bc            ubc
--
-- Note: Sum over index u means contraction.

GAMUDD = dot(guu,GAMDDD)

-- Step 3. Calculate the Riemann tensor. ("Gravitation" by MTW p. 219)
--
-- a is alpha
-- b is beta
-- c is gamma
-- d is delta
-- u is mu
--
--  a           a            a            a        u          a        u
-- R     = Gamma      - Gamma      + Gamma    Gamma    - Gamma    Gamma
--   bcd         bd,c         bc,d         uc       bd         ud       bc
--
-- Do the gradient once and save in a temporary variable.

T1 = d(GAMUDD,X)

-- T2 is the product Gamma Gamma contracted over u.

T2 = dot(transpose(GAMUDD,2,3),GAMUDD)

-- Now put it all together. Transpose indices to match abcd.

RUDDD = transpose(T1,3,4) -             -- transpose d and c
  T1 +                                  -- already in correct order
  transpose(T2,2,3) -                   -- transpose c and b
  transpose(transpose(T2,2,3),3,4)      -- transpose d and b, then d and c

-- Step 4: Calculate the Ricci tensor. ("Gravitation" by MTW p. 343)
--
--        a
-- R   = R
--  uv     uav
--
-- Contract over "a" (1st and 3rd indices).

RDD = contract(RUDDD,1,3)

-- Step 5: Calculate the Ricci scalar. ("Gravitation" by MTW p. 343)
--
--      uv
-- R = g   R
--          uv

R = contract(dot(guu,transpose(RDD)))

-- Step 6: Finally, calculate the Einstein tensor. ("Gravitation" by MTW p. 343)
--
-- G   = R   - 1/2 g   R
--  uv    uv        uv

GDD = RDD - 1/2 * gdd * R

-- Define F(r) and simplify.

F(r) = 1 - 2*M/r

check(GDD == 0)
"Spherical harmonics"

clear

Y(l,m) = (-1)^m sqrt((2l + 1) / (4 pi) (l - m)! / (l + m)!) *
         P(l,m) exp(i m phi)

-- associated legendre of cos theta

P(l,m) = test(m < 0, (-1)^m (l + m)! / (l - m)! P(l,-m),
         1 / (2^l l!) sin(theta)^m *
         eval(d((x^2 - 1)^l,x,l + m),x,cos(theta)))

Lap(f) = 1 / sin(theta) d(sin(theta) d(f,theta),theta) +
         1 / sin(theta)^2 d(f,phi,2)

for(l,0,3,for(m,-l,l,check(-Lap(Y(l,m)) == l (l + 1) Y(l,m))))

check(Y(1,1) == -sqrt(3 / 8 / pi) sin(theta) exp(i phi))
check(Y(1,0) == sqrt(3 / 4 / pi) cos(theta))
check(Y(2,2) == 1/4 sqrt(15 / 2 / pi) sin(theta)^2 exp(2 i phi))
check(Y(2,1) == -sqrt(15 / 8 / pi) sin(theta) cos(theta) exp(i phi))
check(Y(2,0) == 1/2 sqrt(5 / 4 / pi) (3 cos(theta)^2 - 1))

check(Y(1,-1) == -conj(Y(1,1)))
check(Y(2,-2) == conj(Y(2,2)))
check(Y(2,-1) == -conj(Y(2,1)))
"Spinor identities"

clear

E1 = sqrt(p1x^2 + p1y^2 + p1z^2 + m1^2)
E2 = sqrt(p2x^2 + p2y^2 + p2z^2 + m2^2)
E3 = sqrt(p3x^2 + p3y^2 + p3z^2 + m3^2)
E4 = sqrt(p4x^2 + p4y^2 + p4z^2 + m4^2)
p1 = (E1,p1x,p1y,p1z)
p2 = (E2,p2x,p2y,p2z)
p3 = (E3,p3x,p3y,p3z)
p4 = (E4,p4x,p4y,p4z)
u11 = (E1+m1,0,p1z,p1x+i*p1y)
u12 = (0,E1+m1,p1x-i*p1y,-p1z)
v21 = (p2z,p2x+i*p2y,E2+m2,0)
v22 = (p2x-i*p2y,-p2z,0,E2+m2)
u31 = (E3+m3,0,p3z,p3x+i*p3y)
u32 = (0,E3+m3,p3x-i*p3y,-p3z)
v41 = (p4z,p4x+i*p4y,E4+m4,0)
v42 = (p4x-i*p4y,-p4z,0,E4+m4)
I = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))
gmunu = ((1,0,0,0),(0,-1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma0 = ((1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,-1))
gamma1 = ((0,0,0,1),(0,0,1,0),(0,-1,0,0),(-1,0,0,0))
gamma2 = ((0,0,0,-i),(0,0,i,0),(0,i,0,0),(-i,0,0,0))
gamma3 = ((0,0,1,0),(0,0,0,-1),(-1,0,0,0),(0,1,0,0))
gamma = (gamma0,gamma1,gamma2,gamma3)
pslash1 = dot(p1,gmunu,gamma)
pslash2 = dot(p2,gmunu,gamma)
pslash3 = dot(p3,gmunu,gamma)
pslash4 = dot(p4,gmunu,gamma)

-- dirac equation
check(dot(pslash1-m1*I,u11) == 0)
check(dot(pslash1-m1*I,u12) == 0)
check(dot(pslash2+m2*I,v21) == 0)
check(dot(pslash2+m2*I,v22) == 0)
check(dot(pslash3-m3*I,u31) == 0)
check(dot(pslash3-m3*I,u32) == 0)
check(dot(pslash4+m4*I,v41) == 0)
check(dot(pslash4+m4*I,v42) == 0)

-- completeness
check(outer(u11,dot(conj(u11),gamma0))+outer(u12,dot(conj(u12),gamma0))-
  (E1+m1)*(pslash1+m1*I) == 0)
check(outer(v21,dot(conj(v21),gamma0))+outer(v22,dot(conj(v22),gamma0))-
  (E2+m2)*(pslash2-m2*I) == 0)
check(outer(u31,dot(conj(u31),gamma0))+outer(u32,dot(conj(u32),gamma0))-
  (E3+m3)*(pslash3+m3*I) == 0)
check(outer(v41,dot(conj(v41),gamma0))+outer(v42,dot(conj(v42),gamma0))-
  (E4+m4)*(pslash4-m4*I) == 0)
"Static metric"

clear

# This script calculates the Einstein tensor for a static spherically symmetric
# metric.
#
# Cf. "A first course in general relativity," Bernard F. Schutz, p. 255.
#
# This is the line element for the metric (Equation 10.7)
#
#   2     2 Phi   2    2 Lambda   2    2        2
# ds  = -e      dt  + e         dr  + r  d Omega
#
# where
#
#  2        2    2         2      2            2
# r  d Omega  = r  (d theta  + sin  theta d phi )
#
# Note: Phi and Lambda are both functions of r.

gdd = ((-exp(2 Phi(r)),                0,   0,                0),
       (             0, exp(2 Lambda(r)),   0,                0),
       (             0,                0, r^2,                0),
       (             0,                0,   0, r^2 sin(theta)^2))

# Note: "dd" stands for two "down" indices, "uu" stands for two "up" indices.

# X is our coordinate system. We need this for computing gradients.

X = (t,r,theta,phi)

# Step 1: Calculate guu.

guu = inv(gdd)

# Step 2: Calculate the connection coefficients. Cf. Gravitation, p. 210.
#
# Gamma    = 1/2 (g     + g     - g    )
#      abc         ab,c    ac,b    bc,a
#
# Note: The comma means gradient which increases the rank of gdd by 1.

gddd = d(gdd,X)

# Note: We transpose indices so they match up with Gamma, i.e., we put them in
# alphabetical order.

GAMDDD = 1/2 (gddd +                # indices are already in correct order
transpose(gddd,2,3) -               # transpose c and b
transpose(transpose(gddd,2,3),1,2)) # transpose c and a, then b and a

# Raise first index.
#
#      a      au
# Gamma    = g   Gamma
#       bc            ubc
#
# Note: Sum over index u means contraction.

GAMUDD = contract(outer(guu,GAMDDD),2,3)

# Step 3. Calculate the Riemann tensor. Cf. Gravitation, p. 219.
#
# a is alpha
# b is beta
# c is gamma
# d is delta
# u is mu
#
#  a           a            a            a        u          a        u
# R     = Gamma      - Gamma      + Gamma    Gamma    - Gamma    Gamma
#   bcd         bd,c         bc,d         uc       bd         ud       bc
#
# Do the gradient once and save in a temporary variable.

T1 = d(GAMUDD,X)

# The Gamma Gamma product is a rank 6 tensor with dim 4 per rank.
# That works out to 4 to the 6th or 4,096 elements.
# Of course, we'll do the outer product and contract over u just once and save
# the result in a second temporary variable.

T2 = contract(outer(GAMUDD,GAMUDD),2,4)

# Now put it all together. Do the transpositions so the indices get matched up
# with R on the left, i.e., put them in alphabetical order.

RUDDD = transpose(T1,3,4) -             # transpose d and c
  T1 +                                  # already in correct order
  transpose(T2,2,3) -                   # transpose c and b
  transpose(transpose(T2,2,3),3,4)      # transpose d and b, then d and c

# Step 4: Calculate the Ricci tensor. Cf. Gravitation, p. 343.
#
#        a
# R   = R
#  uv     uav
#
# Contract over "a" (1st and 3rd indices).

RDD = contract(RUDDD,1,3)

# Step 5: Calculate the Ricci scalar. Cf. Gravitation, p. 343.
#
#      uv
# R = g   R
#          vu  ...the book has uv, does it give the same result?
#              Yes because the metric tensor is symmetric so it's ok to
#              transpose.

R = contract(contract(outer(guu,RDD),2,3),1,2)

# Step 6: Finally, calculate the Einstein tensor. Cf. Gravitation, p. 343.
#
# G   = R   - 1/2 g   R
#  uv    uv        uv

GDD = RDD - 1/2 gdd R

# Next we compare this result with Schutz' book. Schutz p. 255 gives the
# following Einstein tensor components (all other components are zero):
#
#        1                d
# G   = ----  exp(2 Phi) ---- [r (1 - exp(-2 Lambda))]
#  tt     2               dr
#        r
#
#          1                                         2
# G   = - ---- exp(2 Lambda) (1 - exp(-2 Lambda)) + --- Phi'
#  rr       2                                        r
#          r
#
#                 2                               2
# G            = r  exp(-2 Lambda) [Phi'' + (Phi')  + Phi'/r
#  theta theta
#
#                                                   - Phi' Lambda' - Lamda'/r]
#
#               2
# G        = sin  theta G
#  phi phi               theta theta

Gtt = 1/r^2 exp(2 Phi(r)) d(r (1 - exp(-2 Lambda(r))),r)

Grr = -1/r^2 exp(2 Lambda(r)) (1 - exp(-2 Lambda(r))) + 2/r d(Phi(r),r)

Gthetatheta = r^2 exp(-2 Lambda(r)) (
  d(d(Phi(r),r),r) +
  d(Phi(r),r)^2 +
  d(Phi(r),r) / r -
  d(Phi(r),r) d(Lambda(r),r) -
  d(Lambda(r),r) / r)

Gphiphi = sin(theta)^2 Gthetatheta

# Put together the expected tensor:

T = ((Gtt,   0,           0,       0),
     (  0, Grr,           0,       0),
     (  0,   0, Gthetatheta,       0),
     (  0,   0,           0, Gphiphi))

# Check that GDD is correct.

check(GDD = T)
"Stokes theorem"
z = 4 - x^2 - y^2
F = (y,z,x)
S = (x,y,z)
z = quote(z) -- clear z for use by curl
f = dot(curl(F),cross(d(S,x),d(S,y)))
x = r cos(theta)
y = r sin(theta)
check(defint(f r,r,0,2,theta,0,2pi) == -4 pi)
x = 2 cos(t)
y = 2 sin(t)
z = 4 - x^2 - y^2
P = y
Q = z
R = x
f = P d(x,t) + Q d(y,t) + R d(z,t)
f = circexp(f)
check(defint(f,t,0,2pi) == -4 pi)
"Surface area"

clear
M1 = ((0,0,0),(0,0,-1),(0,1,0))
M2 = ((0,0,1),(0,0,0),(-1,0,0))
M3 = ((0,-1,0),(1,0,0),(0,0,0))
M = (M1,M2,M3)
cross(u,v) = dot(u,M,v)
z=2
S = (x,y,z)
a = abs(cross(d(S,x),d(S,y)))
T = defint(a,y,-sqrt(1 - x^2),sqrt(1 - x^2),x,-1,1)
check(T = pi)

clear
M1 = ((0,0,0),(0,0,-1),(0,1,0))
M2 = ((0,0,1),(0,0,0),(-1,0,0))
M3 = ((0,-1,0),(1,0,0),(0,0,0))
M = (M1,M2,M3)
cross(u,v) = dot(u,M,v)
z = x^2 + 2y
S = (x,y,z)
a = abs(cross(d(S,x),d(S,y)))
T = defint(a,x,0,1,y,0,1)
check(T = 5/8 log(5) + 3/2)

clear
M1 = ((0,0,0),(0,0,-1),(0,1,0))
M2 = ((0,0,1),(0,0,0),(-1,0,0))
M3 = ((0,-1,0),(1,0,0),(0,0,0))
M = (M1,M2,M3)
cross(u,v) = dot(u,M,v)
x = u cos(v)
y = u sin(v)
z = v
S = (x,y,z)
a = circexp(abs(cross(d(S,u),d(S,v))))
T = defint(a,u,0,1,v,0,3pi)
check(T = 3/2 pi log(1 + sqrt(2)) + 3 pi / sqrt(2))
"Surface integral"
clear
M1 = ((0,0,0),(0,0,-1),(0,1,0))
M2 = ((0,0,1),(0,0,0),(-1,0,0))
M3 = ((0,-1,0),(1,0,0),(0,0,0))
M = (M1,M2,M3)
cross(u,v) = dot(u,M,v)
z = 1 - x^2 - y^2
F = (x y^2 z,-2 x^3,y z^2)
S = (x,y,z)
f = dot(F,cross(d(S,x),d(S,y)))
h = sqrt(1 - x^2)
T = defint(f,y,-h,h,x,-1,1)
check(T = 1/48 pi)
"Vector calculus"

clear

# This script tests 10 vector calculus identities.

# Define the cross product, div, grad, curl and laplacian for
# rectangular coordinates.

cross(u,v) = (
  u[2] v[3] - u[3] v[2],
  u[3] v[1] - u[1] v[3],
  u[1] v[2] - u[2] v[1]
)

div(v) = contract(d(v,(x,y,z)),1,2)

grad(v) = d(v,(x,y,z))

curl(f) = (
  d(f[3],y) - d(f[2],z),
  d(f[1],z) - d(f[3],x),
  d(f[2],x) - d(f[1],y)
)

laplacian(f) = d(d(f,x),x) + d(d(f,y),y) + d(d(f,z),z)

# Note: Functions can be left undefined, such as FX(), FY(), etc.
# These "generic" functions, when evaluated by the derivative function d(),
# are considered to be dependent on all variables.
# Basically what this means is that d() does no evaluation at all.
# For example, d(FX(),x) returns the expression d(FX(),x).

# Define generic vector functions F and G.

F = (FX(),FY(),FZ())
G = (GX(),GY(),GZ())

# Now check the 10 identities.

-- 1. div(curl F) = 0

A = div(curl(F))

check(A = 0)

-- 2. curl(grad f) = 0

A = curl(grad(f())) # Note the use of generic scalar function f() here.

check(A = 0)

-- 3. div(grad f) = laplacian f

A = div(grad(f()))

B = laplacian(f())

check(A = B)

-- 4. curl(curl F) = grad(div F) - laplacian F

A = curl(curl(F))

B = grad(div(F)) - laplacian(F)

check(A = B)

-- 5. grad(fg) = f grad g + g grad(f)

A = grad(f() g())

B = f() grad(g()) + g() grad(f())

check(A = B)

-- 6. grad(F . G) = (G . grad)F + (F . grad)G + G x curl F + F x curl G

A = grad(dot(F,G))

B = dot(grad(F),G)+dot(grad(G),F)+cross(G,curl(F))+cross(F,curl(G))

check(A = B)

# Note: It turns out that (G . grad)F actually means (grad F) . G

-- 7. div(fF) = f div F + grad f . F

A = div(f() F)

B = f() div(F) + dot(grad(f()),F)

check(A = B)

-- 8. div(F x G) = G . curl F - F . curl G

A = div(cross(F,G))

B = dot(G,curl(F)) - dot(F,curl(G))

check(A = B)

-- 9. curl(fF) = f curl F + grad f x F

A = curl(f() F)

B = f() curl(F) + cross(grad(f()),F)

check(A = B)

-- 10. curl(F x G) = F div G - G div F + (G . grad)F - (F . grad)G

A = curl(cross(F,G))

B = F div(G) - G div(F) + dot(grad(F),G) - dot(grad(G),F)

check(A = B)
"ok"
clear
status
exit
